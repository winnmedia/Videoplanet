/**
 * 콘티 이미지 생성 API 엔드포인트
 * Google 이미지 생성 API를 활용한 스토리보드 콘티 생성
 */

import { NextRequest, NextResponse } from 'next/server'
import { writeFile, mkdir } from 'fs/promises'
import { existsSync } from 'fs'
import { join } from 'path'
import type {
  ImageGenerationRequest,
  ImageGenerationResponse,
  APIResponse
} from '@/entities/storyboard'

// ============================
// 1. 타입 정의
// ============================

interface GoogleImageAPIResponse {
  images: Array<{
    image: string // Base64 encoded image
    finishReason: string
    safetyRatings: Array<{
      category: string
      probability: string
    }>
  }>
}

// ============================
// 2. 설정 상수
// ============================

const GOOGLE_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-001:generateImages'
const UPLOAD_DIR = join(process.cwd(), 'public', 'uploads', 'conti')
const MAX_IMAGE_SIZE = 5 * 1024 * 1024 // 5MB
const SUPPORTED_FORMATS = ['png', 'jpg', 'jpeg']

// ============================
// 3. 프롬프트 최적화 함수
// ============================

function optimizePromptForConti(originalPrompt: string, style: string, negativePrompt: string): string {
  // 콘티 스타일에 최적화된 프롬프트 생성
  const baseStyle = 'storyboard pencil sketch, rough, monochrome, hand-drawn style, film storyboard'
  
  // 원본 프롬프트에서 불필요한 요소 제거
  const cleanPrompt = originalPrompt
    .replace(/color|colored|colorful/gi, '')
    .replace(/photographic|realistic|photo-realistic/gi, '')
    .replace(/3d|three-dimensional/gi, '')
    .trim()

  // 콘티 전용 스타일 추가
  const optimizedPrompt = `${baseStyle}, ${style}, ${cleanPrompt}`
  
  // 길이 제한 (Google API 제한)
  return optimizedPrompt.length > 500 ? 
    optimizedPrompt.substring(0, 500) + '...' : 
    optimizedPrompt
}

function generateNegativePrompt(customNegativePrompt?: string): string {
  const defaultNegative = [
    'color', 'colorful', 'photographic', 'realistic', 'photo-realistic',
    'detailed', 'polished', 'digital art', '3d render', 'glossy',
    'text', 'watermark', 'signature', 'frame', 'border',
    'logo', 'copyright', 'website', 'url'
  ].join(', ')
  
  return customNegativePrompt ? 
    `${defaultNegative}, ${customNegativePrompt}` : 
    defaultNegative
}

// ============================
// 4. Google 이미지 생성 API 호출
// ============================

async function callGoogleImageAPI(
  prompt: string, 
  negativePrompt: string
): Promise<GoogleImageAPIResponse> {
  const apiKey = process.env.GOOGLE_API_KEY
  
  if (!apiKey) {
    throw new Error('Google API key not configured')
  }

  const requestBody = {
    instances: [{
      prompt: prompt,
      negative_prompt: negativePrompt,
      // 콘티 이미지 최적화 설정
      aspect_ratio: "16:9", // 영상 비율에 맞춤
      safety_filter_level: "block_few", // 안전 필터 레벨
      person_generation: "allow_adult", // 인물 생성 허용
      image_guidance_scale: 15, // 프롬프트 가이던스 강도
      number_of_images: 1
    }],
    parameters: {
      seed: Math.floor(Math.random() * 1000000), // 랜덤 시드
      samples: 1,
      steps: 20, // 생성 스텝 수 (품질 vs 속도)
    }
  }

  const response = await fetch(`${GOOGLE_API_URL}?key=${apiKey}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(requestBody)
  })

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}))
    throw new Error(`Google API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`)
  }

  const data = await response.json()
  
  // 응답 검증
  if (!data.images || !Array.isArray(data.images) || data.images.length === 0) {
    throw new Error('No images generated by Google API')
  }

  return data
}

// ============================
// 5. 이미지 저장 함수
// ============================

async function saveImage(
  base64Image: string, 
  shotId: string, 
  version: number
): Promise<{ filename: string; url: string; size: number }> {
  
  // 업로드 디렉토리 확인/생성
  if (!existsSync(UPLOAD_DIR)) {
    await mkdir(UPLOAD_DIR, { recursive: true })
  }

  // 파일명 생성
  const timestamp = Date.now()
  const filename = `shot-${shotId}-v${version}-${timestamp}.png`
  const filePath = join(UPLOAD_DIR, filename)
  const publicUrl = `/uploads/conti/${filename}`

  try {
    // Base64 디코딩 및 파일 저장
    const imageBuffer = Buffer.from(base64Image, 'base64')
    
    // 파일 크기 검증
    if (imageBuffer.length > MAX_IMAGE_SIZE) {
      throw new Error(`Image size ${imageBuffer.length} exceeds maximum allowed size ${MAX_IMAGE_SIZE}`)
    }

    await writeFile(filePath, imageBuffer)

    return {
      filename,
      url: publicUrl,
      size: imageBuffer.length
    }
  } catch (error) {
    console.error('Failed to save image:', error)
    throw new Error(`Failed to save image: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

// ============================
// 6. 안전성 검사 함수
// ============================

function checkSafetyRatings(safetyRatings: Array<{ category: string; probability: string }>): void {
  const dangerousCategories = ['HARM_CATEGORY_DANGEROUS_CONTENT', 'HARM_CATEGORY_HARASSMENT']
  const highProbabilities = ['MEDIUM', 'HIGH', 'VERY_HIGH']
  
  for (const rating of safetyRatings) {
    if (dangerousCategories.includes(rating.category) && 
        highProbabilities.includes(rating.probability)) {
      throw new Error(`Image generation blocked due to safety concerns: ${rating.category}`)
    }
  }
}

// ============================
// 7. 캐시 관리
// ============================

const imageCache = new Map<string, { 
  url: string; 
  timestamp: number; 
  version: number 
}>()
const CACHE_TTL = 24 * 60 * 60 * 1000 // 24시간

function generateImageCacheKey(shotId: string, prompt: string): string {
  // 프롬프트 기반 캐시 키 생성 (동일한 프롬프트는 재사용)
  const hashInput = `${shotId}_${prompt}`
  let hash = 0
  for (let i = 0; i < hashInput.length; i++) {
    const char = hashInput.charCodeAt(i)
    hash = ((hash << 5) - hash) + char
    hash = hash & hash
  }
  return `img_${Math.abs(hash)}`
}

function getCachedImage(key: string): { url: string; version: number } | null {
  const cached = imageCache.get(key)
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return { url: cached.url, version: cached.version }
  }
  
  if (cached) {
    imageCache.delete(key)
  }
  
  return null
}

function setCachedImage(key: string, url: string, version: number): void {
  imageCache.set(key, { url, timestamp: Date.now(), version })
}

// ============================
// 8. 메인 API 핸들러
// ============================

export async function POST(request: NextRequest): Promise<NextResponse> {
  const startTime = Date.now()
  
  try {
    // 요청 본문 파싱
    const body: ImageGenerationRequest = await request.json()
    
    // 필수 필드 검증
    const requiredFields: (keyof ImageGenerationRequest)[] = [
      'shotId', 'prompt', 'style'
    ]
    
    for (const field of requiredFields) {
      if (!body[field]) {
        return NextResponse.json({
          success: false,
          error: `Missing required field: ${field}`
        } as APIResponse<never>, { status: 400 })
      }
    }

    // 캐시 확인 (재생성이 아닌 경우에만)
    if (!body.isRegeneration) {
      const cacheKey = generateImageCacheKey(body.shotId, body.prompt)
      const cachedImage = getCachedImage(cacheKey)
      
      if (cachedImage) {
        console.log(`Image cache hit for shot: ${body.shotId}`)
        
        const response: ImageGenerationResponse = {
          imageId: `cached_${body.shotId}_${Date.now()}`,
          url: cachedImage.url,
          filename: cachedImage.url.split('/').pop() || '',
          version: cachedImage.version,
          prompt: body.prompt,
          generatedAt: new Date()
        }

        return NextResponse.json({
          success: true,
          data: response
        } as APIResponse<ImageGenerationResponse>)
      }
    }

    // 프롬프트 최적화
    const optimizedPrompt = optimizePromptForConti(
      body.prompt, 
      body.style, 
      body.negativePrompt || ''
    )
    const negativePrompt = generateNegativePrompt(body.negativePrompt)

    console.log(`Generating image for shot ${body.shotId}:`)
    console.log(`Optimized prompt: ${optimizedPrompt}`)
    console.log(`Negative prompt: ${negativePrompt}`)

    // Google 이미지 생성 API 호출
    const googleResponse = await callGoogleImageAPI(optimizedPrompt, negativePrompt)
    const generatedImage = googleResponse.images[0]

    if (!generatedImage) {
      throw new Error('No image data in Google API response')
    }

    // 안전성 검사
    if (generatedImage.safetyRatings) {
      checkSafetyRatings(generatedImage.safetyRatings)
    }

    // 버전 계산
    const version = body.isRegeneration ? (body.previousVersion || 0) + 1 : 1

    // 이미지 저장
    const savedImage = await saveImage(
      generatedImage.image,
      body.shotId,
      version
    )

    // 캐시에 저장
    const cacheKey = generateImageCacheKey(body.shotId, body.prompt)
    setCachedImage(cacheKey, savedImage.url, version)

    const response: ImageGenerationResponse = {
      imageId: `img_${body.shotId}_${Date.now()}`,
      url: savedImage.url,
      filename: savedImage.filename,
      version,
      prompt: optimizedPrompt,
      generatedAt: new Date()
    }

    console.log(`Successfully generated image in ${Date.now() - startTime}ms`)
    console.log(`Image saved: ${savedImage.filename} (${savedImage.size} bytes)`)

    return NextResponse.json({
      success: true,
      data: response,
      message: `Image generated successfully in ${Date.now() - startTime}ms`
    } as APIResponse<ImageGenerationResponse>)

  } catch (error) {
    console.error('Image generation error:', error)
    
    let errorMessage = 'Unknown error occurred'
    let statusCode = 500
    
    if (error instanceof Error) {
      errorMessage = error.message
      
      if (errorMessage.includes('API key')) {
        statusCode = 500
      } else if (errorMessage.includes('safety')) {
        statusCode = 403
      } else if (errorMessage.includes('size exceeds')) {
        statusCode = 413
      } else if (errorMessage.includes('Missing required field')) {
        statusCode = 400
      }
    }

    return NextResponse.json({
      success: false,
      error: errorMessage
    } as APIResponse<never>, { status: statusCode })
  }
}

// ============================
// 9. GET 메서드 (상태 확인용)
// ============================

export async function GET(): Promise<NextResponse> {
  return NextResponse.json({
    success: true,
    message: 'Image generation API is operational',
    data: {
      endpoint: '/api/ai/generate-image',
      method: 'POST',
      cacheSize: imageCache.size,
      maxImageSize: `${MAX_IMAGE_SIZE / (1024 * 1024)}MB`,
      supportedFormats: SUPPORTED_FORMATS,
      uploadDir: '/uploads/conti'
    }
  })
}

// ============================
// 10. DELETE 메서드 (캐시 클리어용)
// ============================

export async function DELETE(): Promise<NextResponse> {
  const cacheSize = imageCache.size
  imageCache.clear()
  
  return NextResponse.json({
    success: true,
    message: `Cleared ${cacheSize} cached images`,
    data: {
      clearedEntries: cacheSize
    }
  })
}