/**
 * Video Entity Types
 * 
 * Schema-first design for video upload/replacement workflows with file management
 * Following FSD architecture principles for entity layer
 */

export type VideoStatus = 
  | 'uploading'
  | 'processing'
  | 'transcoding'
  | 'ready'
  | 'failed'
  | 'archived'
  | 'deleted'

export type VideoQuality = 
  | '240p'
  | '360p'
  | '480p'
  | '720p'
  | '1080p'
  | '1440p'
  | '2160p'
  | 'auto'

export type VideoFormat = 
  | 'mp4'
  | 'webm'
  | 'mov'
  | 'avi'
  | 'mkv'
  | 'flv'

export type VideoCodec = 
  | 'h264'
  | 'h265'
  | 'av1'
  | 'vp8'
  | 'vp9'

export type AccessLevel = 
  | 'public'
  | 'unlisted'
  | 'private'
  | 'password_protected'
  | 'team_only'
  | 'invite_only'

export interface VideoMetadata {
  duration: number // in seconds
  width: number
  height: number
  aspectRatio: string
  frameRate: number
  bitrate: number
  size: number // file size in bytes
  format: VideoFormat
  codec: VideoCodec
  hasAudio: boolean
  audioChannels?: number
  audioSampleRate?: number
  audioBitrate?: number
  colorSpace?: string
  colorRange?: string
  hdr?: boolean
  chapters?: VideoChapter[]
  subtitles?: VideoSubtitle[]
}

export interface VideoChapter {
  id: string
  title: string
  startTime: number
  endTime: number
  thumbnailUrl?: string
  description?: string
  isGenerated: boolean
}

export interface VideoSubtitle {
  id: string
  language: string
  languageCode: string
  label: string
  url: string
  isDefault: boolean
  isAutoGenerated: boolean
  isForced: boolean
}

export interface VideoQualityVariant {
  quality: VideoQuality
  url: string
  width: number
  height: number
  bitrate: number
  fileSize: number
  codec: VideoCodec
  format: VideoFormat
  isReady: boolean
  processingProgress?: number
}

export interface VideoThumbnail {
  id: string
  url: string
  width: number
  height: number
  timestamp: number // time in video where thumbnail was captured
  isDefault: boolean
  isGenerated: boolean
  format: 'jpg' | 'png' | 'webp'
  fileSize: number
}

export interface VideoUploadProgress {
  phase: 'uploading' | 'processing' | 'transcoding' | 'finalizing'
  percentage: number
  bytesUploaded: number
  totalBytes: number
  speed: number // bytes per second
  timeRemaining: number // seconds
  currentTask?: string
  tasksCompleted: number
  totalTasks: number
  retryCount: number
  errors: VideoUploadError[]
}

export interface VideoUploadError {
  code: string
  message: string
  timestamp: string
  phase: VideoUploadProgress['phase']
  retryable: boolean
  details?: Record<string, any>
}

export interface VideoProcessingJob {
  id: string
  videoId: string
  type: 'transcode' | 'thumbnail' | 'subtitle' | 'analysis' | 'optimization'
  status: 'queued' | 'processing' | 'completed' | 'failed' | 'cancelled'
  priority: 'low' | 'normal' | 'high' | 'urgent'
  progress: number
  startedAt?: string
  completedAt?: string
  estimatedDuration?: number
  actualDuration?: number
  workerNode?: string
  resources: {
    cpu: number
    memory: number
    storage: number
  }
  configuration: Record<string, any>
  logs: {
    level: 'debug' | 'info' | 'warn' | 'error'
    message: string
    timestamp: string
    data?: any
  }[]
}

export interface VideoAnalytics {
  viewCount: number
  uniqueViewers: number
  watchTime: number // total seconds watched
  averageWatchTime: number
  completionRate: number // percentage who watched to end
  engagementScore: number // 0-100
  
  viewsByCountry: Record<string, number>
  viewsByDevice: Record<string, number>
  viewsByBrowser: Record<string, number>
  viewsByQuality: Record<VideoQuality, number>
  
  heatmap: {
    timestamp: number
    viewers: number
    engagement: number
  }[]
  
  dropoffPoints: {
    timestamp: number
    dropoffRate: number
    reason?: string
  }[]
  
  feedbackMetrics: {
    totalFeedback: number
    averageRating: number
    sentimentScore: number
    responseTime: number
  }
  
  performance: {
    loadTime: number
    bufferTime: number
    errorRate: number
    qualityChanges: number
  }
}

export interface VideoSecurity {
  drm?: {
    enabled: boolean
    provider: 'widevine' | 'playready' | 'fairplay'
    keyId: string
  }
  
  watermark?: {
    enabled: boolean
    text?: string
    imageUrl?: string
    position: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | 'center'
    opacity: number
    size: number
  }
  
  geoBlocking?: {
    enabled: boolean
    allowedCountries?: string[]
    blockedCountries?: string[]
  }
  
  domainRestriction?: {
    enabled: boolean
    allowedDomains: string[]
  }
  
  downloadProtection: boolean
  rightClickProtection: boolean
  screenshotProtection: boolean
}

export interface VideoVersion {
  id: string
  videoId: string
  version: number
  description: string
  uploadedBy: number
  uploadedAt: string
  fileSize: number
  metadata: VideoMetadata
  isActive: boolean
  replacedBy?: string
  retainedUntil?: string // for version retention policy
}

export interface Video {
  id: string
  projectId: number
  title: string
  description?: string
  status: VideoStatus
  accessLevel: AccessLevel
  password?: string
  
  // File and storage
  originalFileName: string
  fileSize: number
  storageUrl: string
  cdnUrl?: string
  
  // Video properties
  metadata: VideoMetadata
  qualities: VideoQualityVariant[]
  thumbnails: VideoThumbnail[]
  
  // Upload tracking
  uploadProgress?: VideoUploadProgress
  processingJobs: VideoProcessingJob[]
  
  // Versions and replacement
  currentVersion: number
  versions: VideoVersion[]
  isReplacement: boolean
  replacedVideoId?: string
  
  // Access control
  ownerId: number
  editors: number[]
  viewers: number[]
  
  // Analytics and engagement
  analytics: VideoAnalytics
  
  // Security and protection
  security: VideoSecurity
  
  // AI and automation
  aiAnalysis?: {
    contentType: string[]
    topics: string[]
    sentiment: number
    appropriateness: number
    language: string
    transcript?: {
      text: string
      confidence: number
      timestamps: {
        start: number
        end: number
        text: string
        speaker?: string
      }[]
    }
    scenes?: {
      startTime: number
      endTime: number
      description: string
      confidence: number
      tags: string[]
    }[]
    objects?: {
      name: string
      confidence: number
      timestamps: number[]
      boundingBoxes?: {
        timestamp: number
        x: number
        y: number
        width: number
        height: number
      }[]
    }[]
  }
  
  // Timestamps
  createdAt: string
  updatedAt: string
  publishedAt?: string
  archivedAt?: string
  
  // Configuration
  settings: {
    autoplay: boolean
    loop: boolean
    controls: boolean
    muted: boolean
    preload: 'none' | 'metadata' | 'auto'
    playbackRates: number[]
    defaultQuality: VideoQuality
    seekPreview: boolean
    keyboardShortcuts: boolean
    skipIntro?: {
      enabled: boolean
      startTime: number
      endTime: number
    }
    skipOutro?: {
      enabled: boolean
      startTime: number
      endTime: number
    }
  }
  
  // Custom fields and metadata
  tags: string[]
  customFields: Record<string, any>
  
  // Retention and compliance
  retentionPolicy?: {
    deleteAfterDays?: number
    archiveAfterDays?: number
    reason: string
  }
  
  // Backup and redundancy
  backups: {
    id: string
    location: string
    createdAt: string
    size: number
    checksum: string
    encrypted: boolean
  }[]
}

export interface VideoUploadRequest {
  projectId: number
  title: string
  description?: string
  accessLevel?: AccessLevel
  password?: string
  file: File
  replaceVideoId?: string
  settings?: Partial<Video['settings']>
  processingOptions?: {
    generateThumbnails: boolean
    thumbnailCount: number
    generateSubtitles: boolean
    subtitleLanguages: string[]
    qualityOptions: VideoQuality[]
    enableAnalysis: boolean
  }
  tags?: string[]
  customFields?: Record<string, any>
}

export interface VideoUpdateRequest {
  title?: string
  description?: string
  accessLevel?: AccessLevel
  password?: string
  settings?: Partial<Video['settings']>
  tags?: string[]
  customFields?: Record<string, any>
  security?: Partial<VideoSecurity>
}

export interface VideoFilters {
  projectId?: number
  ownerId?: number
  status?: VideoStatus[]
  accessLevel?: AccessLevel[]
  hasPassword?: boolean
  durationRange?: {
    min: number
    max: number
  }
  sizeRange?: {
    min: number
    max: number
  }
  qualityRange?: {
    min: VideoQuality
    max: VideoQuality
  }
  dateRange?: {
    from: string
    to: string
  }
  tags?: string[]
  search?: string
}

export interface VideoSortOptions {
  field: 'createdAt' | 'updatedAt' | 'title' | 'duration' | 'fileSize' | 'viewCount'
  direction: 'asc' | 'desc'
}

export interface VideoListResponse {
  videos: Video[]
  total: number
  page: number
  pageSize: number
  hasMore: boolean
  totalSize: number
  totalDuration: number
  storageUsed: number
  storageLimit: number
}

export interface VideoStats {
  totalVideos: number
  totalSize: number
  totalDuration: number
  averageDuration: number
  averageFileSize: number
  
  byStatus: Record<VideoStatus, number>
  byQuality: Record<VideoQuality, number>
  byFormat: Record<VideoFormat, number>
  byAccessLevel: Record<AccessLevel, number>
  
  uploadMetrics: {
    totalUploads: number
    successfulUploads: number
    failedUploads: number
    averageUploadTime: number
    averageProcessingTime: number
  }
  
  viewingMetrics: {
    totalViews: number
    totalWatchTime: number
    averageViewDuration: number
    uniqueViewers: number
  }
  
  storageMetrics: {
    used: number
    available: number
    quota: number
    byFormat: Record<VideoFormat, number>
    byQuality: Record<VideoQuality, number>
  }
  
  timeRange: {
    from: string
    to: string
  }
}

// Real-time Events
export interface VideoEvent {
  type: 'video_uploaded' | 'video_processing' | 'video_ready' | 'video_failed' | 'video_viewed' | 'video_replaced' | 'video_deleted'
  videoId: string
  projectId: number
  userId: number
  data: Partial<Video>
  timestamp: string
  metadata?: Record<string, any>
}

// Validation Rules
export interface VideoValidationRule {
  field: keyof Video | keyof VideoUploadRequest
  type: 'required' | 'maxSize' | 'format' | 'duration' | 'resolution' | 'custom'
  message: string
  value?: any
  validator?: (value: any, video: Partial<Video>) => boolean
}

export const VIDEO_VALIDATION_RULES: VideoValidationRule[] = [
  {
    field: 'title',
    type: 'required',
    message: 'Video title is required'
  },
  {
    field: 'file',
    type: 'maxSize',
    value: 5 * 1024 * 1024 * 1024, // 5GB
    message: 'Video file cannot exceed 5GB'
  },
  {
    field: 'file',
    type: 'format',
    value: ['mp4', 'webm', 'mov', 'avi'],
    message: 'Supported formats: MP4, WebM, MOV, AVI'
  }
]

// Constants
export const VIDEO_DEFAULTS = {
  STATUS: 'uploading' as VideoStatus,
  ACCESS_LEVEL: 'private' as AccessLevel,
  QUALITY: 'auto' as VideoQuality,
  FORMAT: 'mp4' as VideoFormat,
  CODEC: 'h264' as VideoCodec,
  PAGE_SIZE: 20,
  THUMBNAIL_COUNT: 5,
  CHUNK_SIZE: 5 * 1024 * 1024, // 5MB chunks
  MAX_RETRIES: 3,
  PROCESSING_TIMEOUT: 3600, // 1 hour
  SETTINGS: {
    autoplay: false,
    loop: false,
    controls: true,
    muted: false,
    preload: 'metadata' as const,
    playbackRates: [0.5, 0.75, 1, 1.25, 1.5, 2],
    defaultQuality: 'auto' as VideoQuality,
    seekPreview: true,
    keyboardShortcuts: true
  }
} as const

export const VIDEO_LIMITS = {
  MAX_FILE_SIZE: 5 * 1024 * 1024 * 1024, // 5GB
  MAX_DURATION: 4 * 60 * 60, // 4 hours
  MAX_TITLE_LENGTH: 200,
  MAX_DESCRIPTION_LENGTH: 5000,
  MAX_TAGS: 20,
  MAX_VERSIONS: 10,
  MAX_THUMBNAILS: 20,
  MAX_SUBTITLES: 10,
  MAX_CHAPTERS: 100,
  MIN_RESOLUTION: { width: 240, height: 180 },
  MAX_RESOLUTION: { width: 3840, height: 2160 }
} as const

export const SUPPORTED_FORMATS: Record<VideoFormat, {
  extensions: string[]
  codecs: VideoCodec[]
  maxSize: number
  description: string
}> = {
  mp4: {
    extensions: ['.mp4', '.m4v'],
    codecs: ['h264', 'h265'],
    maxSize: VIDEO_LIMITS.MAX_FILE_SIZE,
    description: 'MP4 (recommended)'
  },
  webm: {
    extensions: ['.webm'],
    codecs: ['vp8', 'vp9', 'av1'],
    maxSize: VIDEO_LIMITS.MAX_FILE_SIZE,
    description: 'WebM'
  },
  mov: {
    extensions: ['.mov', '.qt'],
    codecs: ['h264', 'h265'],
    maxSize: VIDEO_LIMITS.MAX_FILE_SIZE,
    description: 'QuickTime MOV'
  },
  avi: {
    extensions: ['.avi'],
    codecs: ['h264'],
    maxSize: VIDEO_LIMITS.MAX_FILE_SIZE,
    description: 'AVI'
  },
  mkv: {
    extensions: ['.mkv'],
    codecs: ['h264', 'h265', 'av1'],
    maxSize: VIDEO_LIMITS.MAX_FILE_SIZE,
    description: 'Matroska MKV'
  },
  flv: {
    extensions: ['.flv'],
    codecs: ['h264'],
    maxSize: VIDEO_LIMITS.MAX_FILE_SIZE,
    description: 'Flash Video (legacy)'
  }
} as const

export const QUALITY_SETTINGS: Record<VideoQuality, {
  width: number
  height: number
  bitrate: number
  description: string
}> = {
  '240p': { width: 426, height: 240, bitrate: 400, description: '240p (Low)' },
  '360p': { width: 640, height: 360, bitrate: 800, description: '360p (Medium)' },
  '480p': { width: 854, height: 480, bitrate: 1200, description: '480p (High)' },
  '720p': { width: 1280, height: 720, bitrate: 2500, description: '720p HD' },
  '1080p': { width: 1920, height: 1080, bitrate: 5000, description: '1080p Full HD' },
  '1440p': { width: 2560, height: 1440, bitrate: 10000, description: '1440p 2K' },
  '2160p': { width: 3840, height: 2160, bitrate: 20000, description: '2160p 4K' },
  'auto': { width: 0, height: 0, bitrate: 0, description: 'Auto (Adaptive)' }
} as const