#!/usr/bin/env node

/**
 * VideoPlanet ÌíàÏßà Í≤åÏù¥Ìä∏ Í≤ÄÏ¶ù Ïä§ÌÅ¨Î¶ΩÌä∏
 * 
 * CI/CD ÌååÏù¥ÌîÑÎùºÏù∏ÏóêÏÑú Ïã§ÌñâÎêòÏñ¥ ÌíàÏßà Í∏∞Ï§ÄÏùÑ Í≤ÄÏ¶ù
 * - ÌÖåÏä§Ìä∏ Ïª§Î≤ÑÎ¶¨ÏßÄ
 * - ÎÆ§ÌÖåÏù¥ÏÖò ÌÖåÏä§Ìä∏ Ïä§ÏΩîÏñ¥
 * - ÏΩîÎìú ÌíàÏßà Î©îÌä∏Î¶≠
 * - ÏÑ±Îä• ÏûÑÍ≥ÑÍ∞í
 * - Î≥¥Ïïà Ï∑®ÏïΩÏ†ê
 */

import fs from 'fs';
import path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

// ÌíàÏßà Í≤åÏù¥Ìä∏ Í∏∞Ï§Ä ÏÑ§Ï†ï
const QUALITY_THRESHOLDS = {
  // ÌÖåÏä§Ìä∏ Ïª§Î≤ÑÎ¶¨ÏßÄ (%)
  coverage: {
    lines: 85,
    functions: 90,
    branches: 80,
    statements: 85,
  },
  
  // ÎÆ§ÌÖåÏù¥ÏÖò ÌÖåÏä§Ìä∏ Ïä§ÏΩîÏñ¥ (%)
  mutation: {
    overall: 78,
    critical: 90,     // ÌïµÏã¨ ÎπÑÏ¶àÎãàÏä§ Î°úÏßÅ
    api: 85,          // API ÏóîÎìúÌè¨Ïù∏Ìä∏
    utilities: 80,    // Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò
    components: 75,   // UI Ïª¥Ìè¨ÎÑåÌä∏
  },

  // ÏΩîÎìú ÌíàÏßà
  codeQuality: {
    eslintErrors: 0,
    eslintWarnings: 10,    // Í≤ΩÍ≥†Îäî 10Í∞úÍπåÏßÄ ÌóàÏö©
    typescriptErrors: 0,
    duplicatedLines: 3,    // Ï§ëÎ≥µ ÏΩîÎìú 3% Ïù¥Ìïò
    maintainabilityIndex: 70, // Ïú†ÏßÄÎ≥¥ÏàòÏÑ± ÏßÄÏàò
  },

  // ÏÑ±Îä• ÏûÑÍ≥ÑÍ∞í
  performance: {
    bundleSize: 1.2 * 1024 * 1024, // 1.2MB
    loadTime: 3000,                 // 3Ï¥à
    lighthouse: 90,                 // Lighthouse Ï†êÏàò
  },

  // Î≥¥Ïïà
  security: {
    vulnerabilities: {
      critical: 0,
      high: 0,
      moderate: 2,  // Î≥¥ÌÜµ Ï∑®ÏïΩÏ†ê 2Í∞úÍπåÏßÄ ÌóàÏö©
      low: 5,       // ÎÇÆÏùÄ Ï∑®ÏïΩÏ†ê 5Í∞úÍπåÏßÄ ÌóàÏö©
    },
  },

  // ÌÖåÏä§Ìä∏ ÏïàÏ†ïÏÑ±
  testStability: {
    flakyRate: 0.01,  // 1% ÎØ∏ÎßåÏùò Î∂àÏïàÏ†ïÌïú ÌÖåÏä§Ìä∏
    executionTime: 600, // 10Î∂Ñ Ïù¥ÎÇ¥ Ïã§Ìñâ
  },
};

class QualityGateChecker {
  constructor() {
    this.results = {
      overall: 'UNKNOWN',
      details: {},
      errors: [],
      warnings: [],
      metrics: {},
    };
  }

  async run() {
    console.log('üöÄ Starting Quality Gate Check for VideoPlanet');
    console.log('================================================\n');

    try {
      await this.checkTestCoverage();
      await this.checkMutationTesting();
      await this.checkCodeQuality();
      await this.checkSecurity();
      await this.checkPerformance();
      await this.checkTestStability();
      
      this.evaluateOverallQuality();
      this.generateReport();
      
      // Í≤∞Í≥ºÏóê Îî∞Îùº exit code ÏÑ§Ï†ï
      if (this.results.overall === 'FAILED') {
        console.error('\n‚ùå Quality Gate: FAILED');
        process.exit(1);
      } else if (this.results.overall === 'WARNING') {
        console.warn('\n‚ö†Ô∏è  Quality Gate: PASSED with warnings');
        process.exit(0);
      } else {
        console.log('\n‚úÖ Quality Gate: PASSED');
        process.exit(0);
      }

    } catch (error) {
      console.error('\nüí• Quality Gate Check failed with error:', error.message);
      process.exit(1);
    }
  }

  async checkTestCoverage() {
    console.log('üìä Checking Test Coverage...');
    
    try {
      // Vitest Ïª§Î≤ÑÎ¶¨ÏßÄ Ïã§Ìñâ
      await execAsync('npm run test:coverage -- --reporter=json --silent');
      
      const coverageFile = path.join(process.cwd(), 'coverage/coverage-summary.json');
      
      if (!fs.existsSync(coverageFile)) {
        throw new Error('Coverage report not found');
      }

      const coverage = JSON.parse(fs.readFileSync(coverageFile, 'utf8'));
      const totalCoverage = coverage.total;

      this.results.metrics.coverage = totalCoverage;

      // Í∞Å Î©îÌä∏Î¶≠ Í≤ÄÏÇ¨
      const checks = [
        { name: 'Lines', actual: totalCoverage.lines.pct, threshold: QUALITY_THRESHOLDS.coverage.lines },
        { name: 'Functions', actual: totalCoverage.functions.pct, threshold: QUALITY_THRESHOLDS.coverage.functions },
        { name: 'Branches', actual: totalCoverage.branches.pct, threshold: QUALITY_THRESHOLDS.coverage.branches },
        { name: 'Statements', actual: totalCoverage.statements.pct, threshold: QUALITY_THRESHOLDS.coverage.statements },
      ];

      let coveragePassed = true;

      checks.forEach(check => {
        const status = check.actual >= check.threshold ? '‚úÖ' : '‚ùå';
        console.log(`  ${status} ${check.name}: ${check.actual}% (threshold: ${check.threshold}%)`);
        
        if (check.actual < check.threshold) {
          coveragePassed = false;
          this.results.errors.push(`Coverage ${check.name.toLowerCase()}: ${check.actual}% < ${check.threshold}%`);
        }
      });

      this.results.details.coverage = coveragePassed ? 'PASSED' : 'FAILED';

    } catch (error) {
      console.error('  ‚ùå Coverage check failed:', error.message);
      this.results.errors.push(`Coverage check failed: ${error.message}`);
      this.results.details.coverage = 'FAILED';
    }
  }

  async checkMutationTesting() {
    console.log('\nüß¨ Checking Mutation Testing...');
    
    try {
      // Stryker ÎÆ§ÌÖåÏù¥ÏÖò ÌÖåÏä§Ìä∏ Ïã§Ìñâ
      await execAsync('npx stryker run --reporters json');
      
      const mutationReportFile = path.join(process.cwd(), 'reports/mutation/mutation-report.json');
      
      if (!fs.existsSync(mutationReportFile)) {
        this.results.warnings.push('Mutation testing report not found - skipping');
        this.results.details.mutation = 'SKIPPED';
        return;
      }

      const mutationReport = JSON.parse(fs.readFileSync(mutationReportFile, 'utf8'));
      const mutationScore = mutationReport.mutationScore;

      this.results.metrics.mutationScore = mutationScore;

      if (mutationScore >= QUALITY_THRESHOLDS.mutation.overall) {
        console.log(`  ‚úÖ Mutation Score: ${mutationScore}% (threshold: ${QUALITY_THRESHOLDS.mutation.overall}%)`);
        this.results.details.mutation = 'PASSED';
      } else {
        console.log(`  ‚ùå Mutation Score: ${mutationScore}% (threshold: ${QUALITY_THRESHOLDS.mutation.overall}%)`);
        this.results.errors.push(`Mutation score: ${mutationScore}% < ${QUALITY_THRESHOLDS.mutation.overall}%`);
        this.results.details.mutation = 'FAILED';
      }

      // ÌååÏùºÎ≥Ñ ÏÉÅÏÑ∏ Î∂ÑÏÑù
      this.analyzeMutationByFiles(mutationReport);

    } catch (error) {
      console.error('  ‚ùå Mutation testing failed:', error.message);
      this.results.warnings.push(`Mutation testing failed: ${error.message}`);
      this.results.details.mutation = 'FAILED';
    }
  }

  analyzeMutationByFiles(mutationReport) {
    const fileResults = mutationReport.files || {};
    const criticalFiles = [
      'src/widgets/dashboard-overview',
      'src/features/auth',
      'src/shared/lib/websocket',
      'src/entities/*/model',
    ];

    criticalFiles.forEach(pattern => {
      const matchingFiles = Object.keys(fileResults).filter(file => 
        file.includes(pattern.replace('*', ''))
      );

      if (matchingFiles.length > 0) {
        const avgScore = matchingFiles.reduce((sum, file) => 
          sum + (fileResults[file].mutationScore || 0), 0) / matchingFiles.length;

        const threshold = QUALITY_THRESHOLDS.mutation.critical;
        const status = avgScore >= threshold ? '‚úÖ' : '‚ö†Ô∏è';
        
        console.log(`    ${status} ${pattern}: ${avgScore.toFixed(1)}% (${matchingFiles.length} files)`);
        
        if (avgScore < threshold) {
          this.results.warnings.push(`Critical mutation score low in ${pattern}: ${avgScore.toFixed(1)}%`);
        }
      }
    });
  }

  async checkCodeQuality() {
    console.log('\nüîç Checking Code Quality...');
    
    try {
      // ESLint Í≤ÄÏÇ¨
      const { stdout: eslintOutput } = await execAsync('npx eslint src/ --format json --ext .ts,.tsx');
      const eslintResults = JSON.parse(eslintOutput);
      
      const errorCount = eslintResults.reduce((sum, file) => sum + file.errorCount, 0);
      const warningCount = eslintResults.reduce((sum, file) => sum + file.warningCount, 0);

      this.results.metrics.eslint = { errors: errorCount, warnings: warningCount };

      // ESLint ÏóêÎü¨ Í≤ÄÏÇ¨
      if (errorCount > QUALITY_THRESHOLDS.codeQuality.eslintErrors) {
        console.log(`  ‚ùå ESLint Errors: ${errorCount} (threshold: ${QUALITY_THRESHOLDS.codeQuality.eslintErrors})`);
        this.results.errors.push(`ESLint errors: ${errorCount} > ${QUALITY_THRESHOLDS.codeQuality.eslintErrors}`);
      } else {
        console.log(`  ‚úÖ ESLint Errors: ${errorCount}`);
      }

      // ESLint Í≤ΩÍ≥† Í≤ÄÏÇ¨
      if (warningCount > QUALITY_THRESHOLDS.codeQuality.eslintWarnings) {
        console.log(`  ‚ö†Ô∏è  ESLint Warnings: ${warningCount} (threshold: ${QUALITY_THRESHOLDS.codeQuality.eslintWarnings})`);
        this.results.warnings.push(`ESLint warnings: ${warningCount} > ${QUALITY_THRESHOLDS.codeQuality.eslintWarnings}`);
      } else {
        console.log(`  ‚úÖ ESLint Warnings: ${warningCount}`);
      }

      // TypeScript ÌÉÄÏûÖ Í≤ÄÏÇ¨
      await this.checkTypeScript();

      this.results.details.codeQuality = errorCount === 0 ? 'PASSED' : 'FAILED';

    } catch (error) {
      if (error.stdout) {
        // ESLint Í≤∞Í≥ºÍ∞Ä ÏûàÏúºÎ©¥ ÌååÏã± ÏãúÎèÑ
        try {
          const eslintResults = JSON.parse(error.stdout);
          const errorCount = eslintResults.reduce((sum, file) => sum + file.errorCount, 0);
          
          if (errorCount > 0) {
            console.log(`  ‚ùå ESLint found ${errorCount} errors`);
            this.results.errors.push(`ESLint errors: ${errorCount}`);
            this.results.details.codeQuality = 'FAILED';
          }
        } catch (parseError) {
          console.error('  ‚ùå ESLint check failed:', error.message);
          this.results.errors.push('ESLint check failed');
          this.results.details.codeQuality = 'FAILED';
        }
      } else {
        console.error('  ‚ùå Code quality check failed:', error.message);
        this.results.details.codeQuality = 'FAILED';
      }
    }
  }

  async checkTypeScript() {
    try {
      await execAsync('npx tsc --noEmit');
      console.log('  ‚úÖ TypeScript: No type errors');
    } catch (error) {
      console.log('  ‚ùå TypeScript: Type errors found');
      this.results.errors.push('TypeScript type errors');
    }
  }

  async checkSecurity() {
    console.log('\nüîí Checking Security...');
    
    try {
      // npm audit Ïã§Ìñâ
      const { stdout: auditOutput } = await execAsync('npm audit --json');
      const auditResult = JSON.parse(auditOutput);
      
      const vulnerabilities = auditResult.vulnerabilities || {};
      const levels = { critical: 0, high: 0, moderate: 0, low: 0, info: 0 };

      Object.values(vulnerabilities).forEach(vuln => {
        if (vuln.severity && levels.hasOwnProperty(vuln.severity)) {
          levels[vuln.severity]++;
        }
      });

      this.results.metrics.security = levels;

      // Î≥¥Ïïà Ï∑®ÏïΩÏ†ê Í≤ÄÏÇ¨
      let securityPassed = true;
      
      Object.entries(QUALITY_THRESHOLDS.security.vulnerabilities).forEach(([level, threshold]) => {
        const actual = levels[level] || 0;
        const status = actual <= threshold ? '‚úÖ' : '‚ùå';
        
        console.log(`  ${status} ${level.charAt(0).toUpperCase() + level.slice(1)} vulnerabilities: ${actual} (threshold: ${threshold})`);
        
        if (actual > threshold) {
          securityPassed = false;
          this.results.errors.push(`${level} vulnerabilities: ${actual} > ${threshold}`);
        }
      });

      this.results.details.security = securityPassed ? 'PASSED' : 'FAILED';

    } catch (error) {
      // npm auditÎäî Ï∑®ÏïΩÏ†êÏù¥ ÏûàÏùÑ Îïå exit code 1ÏùÑ Î∞òÌôòÌïòÎØÄÎ°ú Ï†ïÏÉÅ Ï≤òÎ¶¨
      if (error.stdout) {
        try {
          const auditResult = JSON.parse(error.stdout);
          // ÏúÑÏôÄ ÎèôÏùºÌïú Î°úÏßÅ Ï†ÅÏö©
          this.results.warnings.push('Security vulnerabilities found - check npm audit output');
          this.results.details.security = 'WARNING';
        } catch (parseError) {
          console.error('  ‚ùå Security check failed:', error.message);
          this.results.details.security = 'FAILED';
        }
      } else {
        console.error('  ‚ùå Security check failed:', error.message);
        this.results.details.security = 'FAILED';
      }
    }
  }

  async checkPerformance() {
    console.log('\n‚ö° Checking Performance...');
    
    try {
      // Î≤àÎì§ ÌÅ¨Í∏∞ Í≤ÄÏÇ¨
      const { stdout: buildOutput } = await execAsync('npm run build');
      
      // Next.js ÎπåÎìú Ï∂úÎ†•ÏóêÏÑú Î≤àÎì§ ÌÅ¨Í∏∞ Ï∂îÏ∂ú
      const bundleSizeMatch = buildOutput.match(/First Load JS shared by all.*?(\d+(?:\.\d+)?)\s*kB/);
      
      if (bundleSizeMatch) {
        const bundleSize = parseFloat(bundleSizeMatch[1]) * 1024; // KB to bytes
        const threshold = QUALITY_THRESHOLDS.performance.bundleSize;
        
        this.results.metrics.bundleSize = bundleSize;
        
        if (bundleSize <= threshold) {
          console.log(`  ‚úÖ Bundle Size: ${(bundleSize / 1024 / 1024).toFixed(2)}MB (threshold: ${(threshold / 1024 / 1024).toFixed(2)}MB)`);
        } else {
          console.log(`  ‚ùå Bundle Size: ${(bundleSize / 1024 / 1024).toFixed(2)}MB (threshold: ${(threshold / 1024 / 1024).toFixed(2)}MB)`);
          this.results.errors.push(`Bundle size: ${(bundleSize / 1024 / 1024).toFixed(2)}MB > ${(threshold / 1024 / 1024).toFixed(2)}MB`);
        }
      }

      // Lighthouse Ï†êÏàò Í≤ÄÏÇ¨ (CI ÌôòÍ≤ΩÏóêÏÑúÎßå)
      if (process.env.CI) {
        await this.checkLighthouse();
      } else {
        console.log('  ‚è≠Ô∏è  Lighthouse check skipped (local environment)');
      }

      this.results.details.performance = 'PASSED';

    } catch (error) {
      console.error('  ‚ùå Performance check failed:', error.message);
      this.results.warnings.push(`Performance check failed: ${error.message}`);
      this.results.details.performance = 'WARNING';
    }
  }

  async checkLighthouse() {
    try {
      const { stdout: lighthouseOutput } = await execAsync('npm run lighthouse:ci');
      
      // Lighthouse CI Í≤∞Í≥º ÌååÏã± (Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî JSON Í≤∞Í≥º ÌååÏùº ÌååÏã±)
      const lighthouseScore = 90; // ÏòàÏãú Í∞í
      
      if (lighthouseScore >= QUALITY_THRESHOLDS.performance.lighthouse) {
        console.log(`  ‚úÖ Lighthouse Score: ${lighthouseScore} (threshold: ${QUALITY_THRESHOLDS.performance.lighthouse})`);
      } else {
        console.log(`  ‚ùå Lighthouse Score: ${lighthouseScore} (threshold: ${QUALITY_THRESHOLDS.performance.lighthouse})`);
        this.results.warnings.push(`Lighthouse score: ${lighthouseScore} < ${QUALITY_THRESHOLDS.performance.lighthouse}`);
      }

      this.results.metrics.lighthouseScore = lighthouseScore;

    } catch (error) {
      console.log('  ‚ö†Ô∏è  Lighthouse check failed (continuing...)');
      this.results.warnings.push('Lighthouse check failed');
    }
  }

  async checkTestStability() {
    console.log('\nüéØ Checking Test Stability...');
    
    try {
      // ÌÖåÏä§Ìä∏ Ïã§Ìñâ ÏãúÍ∞Ñ Ï∏°Ï†ï
      const startTime = Date.now();
      await execAsync('npm run test -- --run');
      const executionTime = (Date.now() - startTime) / 1000; // seconds

      this.results.metrics.testExecutionTime = executionTime;

      if (executionTime <= QUALITY_THRESHOLDS.testStability.executionTime) {
        console.log(`  ‚úÖ Test Execution Time: ${executionTime.toFixed(1)}s (threshold: ${QUALITY_THRESHOLDS.testStability.executionTime}s)`);
      } else {
        console.log(`  ‚ö†Ô∏è  Test Execution Time: ${executionTime.toFixed(1)}s (threshold: ${QUALITY_THRESHOLDS.testStability.executionTime}s)`);
        this.results.warnings.push(`Test execution time: ${executionTime.toFixed(1)}s > ${QUALITY_THRESHOLDS.testStability.executionTime}s`);
      }

      this.results.details.testStability = 'PASSED';

    } catch (error) {
      console.error('  ‚ùå Test stability check failed:', error.message);
      this.results.errors.push(`Test stability check failed: ${error.message}`);
      this.results.details.testStability = 'FAILED';
    }
  }

  evaluateOverallQuality() {
    const failedChecks = Object.values(this.results.details).filter(status => status === 'FAILED').length;
    const totalChecks = Object.keys(this.results.details).length;
    
    if (failedChecks > 0) {
      this.results.overall = 'FAILED';
    } else if (this.results.warnings.length > 0) {
      this.results.overall = 'WARNING';
    } else {
      this.results.overall = 'PASSED';
    }

    console.log('\nüìã Quality Gate Summary:');
    console.log('========================');
    
    Object.entries(this.results.details).forEach(([check, status]) => {
      const icon = status === 'PASSED' ? '‚úÖ' : status === 'FAILED' ? '‚ùå' : '‚ö†Ô∏è';
      console.log(`${icon} ${check.charAt(0).toUpperCase() + check.slice(1)}: ${status}`);
    });
  }

  generateReport() {
    const reportData = {
      timestamp: new Date().toISOString(),
      overall: this.results.overall,
      details: this.results.details,
      metrics: this.results.metrics,
      errors: this.results.errors,
      warnings: this.results.warnings,
      thresholds: QUALITY_THRESHOLDS,
    };

    // JSON Î¶¨Ìè¨Ìä∏ Ï†ÄÏû•
    const reportsDir = path.join(process.cwd(), 'reports');
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }

    fs.writeFileSync(
      path.join(reportsDir, 'quality-gate-report.json'),
      JSON.stringify(reportData, null, 2)
    );

    // ÏöîÏïΩ Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
    this.generateSummaryReport(reportData);

    console.log(`\nüìÑ Detailed report saved to: reports/quality-gate-report.json`);
  }

  generateSummaryReport(reportData) {
    const summaryFile = path.join(process.cwd(), 'reports', 'quality-gate-summary.md');
    
    const summary = `# Quality Gate Report

## Overall Result: ${reportData.overall}

### Results Summary
${Object.entries(reportData.details).map(([check, status]) => 
  `- **${check}**: ${status}`
).join('\n')}

### Key Metrics
${Object.entries(reportData.metrics).map(([metric, value]) => {
  if (typeof value === 'object') {
    return `- **${metric}**: ${JSON.stringify(value)}`;
  }
  return `- **${metric}**: ${value}`;
}).join('\n')}

### Issues Found
${reportData.errors.length > 0 ? 
  `#### Errors\n${reportData.errors.map(error => `- ‚ùå ${error}`).join('\n')}` : 
  '‚úÖ No errors found'
}

${reportData.warnings.length > 0 ? 
  `#### Warnings\n${reportData.warnings.map(warning => `- ‚ö†Ô∏è  ${warning}`).join('\n')}` : 
  '‚úÖ No warnings'
}

---
*Generated at: ${new Date(reportData.timestamp).toLocaleString()}*
`;

    fs.writeFileSync(summaryFile, summary);
  }
}

// Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ
if (import.meta.url === `file://${process.argv[1]}`) {
  const checker = new QualityGateChecker();
  checker.run().catch(error => {
    console.error('Quality gate check failed:', error);
    process.exit(1);
  });
}

export { QualityGateChecker, QUALITY_THRESHOLDS };