# VideoPlanet 일정 관리 시스템 FSD 아키텍처

## 1. Schedule Entity 도메인 모델

### 1.1 TypeScript 타입 정의

```typescript
// src/entities/schedule/model/types.ts

export type ProjectPhase = 'planning' | 'shooting' | 'editing'

export type ScheduleMode = 'auto' | 'manual'

export type TaskStatus = 'not_started' | 'in_progress' | 'completed' | 'blocked' | 'cancelled'

export interface ScheduleTask {
  id: string
  title: string
  description?: string
  phase: ProjectPhase
  startDate: Date
  endDate: Date
  duration: number // in hours
  progress: number // 0-100
  status: TaskStatus
  assignees: number[] // User IDs
  dependencies: string[] // Task IDs
  isAutogenerated: boolean
  metadata: {
    estimatedHours: number
    actualHours?: number
    priority: 'low' | 'medium' | 'high' | 'critical'
    tags: string[]
  }
}

export interface ProjectSchedule {
  id: string
  projectId: number
  mode: ScheduleMode
  createdAt: Date
  updatedAt: Date
  
  // Phase configuration
  phases: {
    [K in ProjectPhase]: {
      startDate: Date
      endDate: Date
      duration: number
      isActive: boolean
      progress: number
      tasks: ScheduleTask[]
    }
  }
  
  // Global schedule settings
  settings: {
    workingDays: number[] // 0=Sunday, 1=Monday, etc.
    workingHours: {
      start: string // "09:00"
      end: string   // "18:00"
    }
    holidays: Date[]
    bufferPercentage: number // 10 = 10% buffer time
    autoProgressTracking: boolean
    notificationSettings: {
      deadlineReminders: boolean
      dailyUpdates: boolean
      milestoneAlerts: boolean
    }
  }
  
  // Milestones
  milestones: {
    id: string
    title: string
    date: Date
    phase: ProjectPhase
    isCompleted: boolean
    description?: string
  }[]
  
  // Statistics
  stats: {
    totalTasks: number
    completedTasks: number
    overdueTasks: number
    totalEstimatedHours: number
    totalActualHours: number
    averageTaskCompletion: number
    phaseCompletionRates: Record<ProjectPhase, number>
  }
}

// Extended Project interface with schedule
export interface ProjectWithSchedule extends Project {
  schedule?: ProjectSchedule
  hasCustomSchedule: boolean
  scheduleLastUpdated?: Date
}
```

### 1.2 Schedule Redux Slice

```typescript
// src/entities/schedule/model/schedule.slice.ts

import { createSlice, PayloadAction } from '@reduxjs/toolkit'
import { ScheduleTask, ProjectSchedule, ProjectPhase, TaskStatus } from './types'

interface ScheduleState {
  schedules: Record<number, ProjectSchedule> // projectId -> schedule
  currentSchedule: ProjectSchedule | null
  selectedPhase: ProjectPhase | null
  viewMode: 'gantt' | 'calendar' | 'list'
  timeframe: 'day' | 'week' | 'month'
  isLoading: boolean
  error: string | null
  
  // Filters
  filters: {
    phases: ProjectPhase[]
    assignees: number[]
    statuses: TaskStatus[]
    dateRange?: {
      start: Date
      end: Date
    }
  }
  
  // UI State
  ui: {
    selectedTasks: string[]
    expandedPhases: ProjectPhase[]
    showCompleted: boolean
    showDependencies: boolean
  }
}

const initialState: ScheduleState = {
  schedules: {},
  currentSchedule: null,
  selectedPhase: null,
  viewMode: 'gantt',
  timeframe: 'week',
  isLoading: false,
  error: null,
  filters: {
    phases: [],
    assignees: [],
    statuses: [],
  },
  ui: {
    selectedTasks: [],
    expandedPhases: ['planning', 'shooting', 'editing'],
    showCompleted: true,
    showDependencies: true,
  }
}

const scheduleSlice = createSlice({
  name: 'schedule',
  initialState,
  reducers: {
    // Schedule CRUD
    setSchedule: (state, action: PayloadAction<ProjectSchedule>) => {
      const schedule = action.payload
      state.schedules[schedule.projectId] = schedule
      state.currentSchedule = schedule
      state.error = null
    },
    
    setCurrentSchedule: (state, action: PayloadAction<number>) => {
      const projectId = action.payload
      state.currentSchedule = state.schedules[projectId] || null
    },
    
    updateScheduleSettings: (state, action: PayloadAction<{
      projectId: number
      settings: Partial<ProjectSchedule['settings']>
    }>) => {
      const { projectId, settings } = action.payload
      if (state.schedules[projectId]) {
        state.schedules[projectId].settings = {
          ...state.schedules[projectId].settings,
          ...settings
        }
      }
    },
    
    // Task CRUD
    addTask: (state, action: PayloadAction<{
      projectId: number
      phase: ProjectPhase
      task: ScheduleTask
    }>) => {
      const { projectId, phase, task } = action.payload
      if (state.schedules[projectId]) {
        state.schedules[projectId].phases[phase].tasks.push(task)
        state.schedules[projectId].updatedAt = new Date()
      }
    },
    
    updateTask: (state, action: PayloadAction<{
      projectId: number
      taskId: string
      updates: Partial<ScheduleTask>
    }>) => {
      const { projectId, taskId, updates } = action.payload
      const schedule = state.schedules[projectId]
      if (schedule) {
        for (const phase of Object.values(schedule.phases)) {
          const taskIndex = phase.tasks.findIndex(t => t.id === taskId)
          if (taskIndex !== -1) {
            phase.tasks[taskIndex] = { ...phase.tasks[taskIndex], ...updates }
            schedule.updatedAt = new Date()
            break
          }
        }
      }
    },
    
    removeTask: (state, action: PayloadAction<{
      projectId: number
      taskId: string
    }>) => {
      const { projectId, taskId } = action.payload
      const schedule = state.schedules[projectId]
      if (schedule) {
        for (const phase of Object.values(schedule.phases)) {
          phase.tasks = phase.tasks.filter(t => t.id !== taskId)
        }
        schedule.updatedAt = new Date()
      }
    },
    
    // Bulk operations
    updateTasksProgress: (state, action: PayloadAction<{
      projectId: number
      updates: Array<{ taskId: string; progress: number; status?: TaskStatus }>
    }>) => {
      const { projectId, updates } = action.payload
      const schedule = state.schedules[projectId]
      if (schedule) {
        updates.forEach(({ taskId, progress, status }) => {
          for (const phase of Object.values(schedule.phases)) {
            const task = phase.tasks.find(t => t.id === taskId)
            if (task) {
              task.progress = progress
              if (status) task.status = status
              break
            }
          }
        })
        schedule.updatedAt = new Date()
      }
    },
    
    // View management
    setViewMode: (state, action: PayloadAction<ScheduleState['viewMode']>) => {
      state.viewMode = action.payload
    },
    
    setTimeframe: (state, action: PayloadAction<ScheduleState['timeframe']>) => {
      state.timeframe = action.payload
    },
    
    setSelectedPhase: (state, action: PayloadAction<ProjectPhase | null>) => {
      state.selectedPhase = action.payload
    },
    
    // Filters
    setFilters: (state, action: PayloadAction<Partial<ScheduleState['filters']>>) => {
      state.filters = { ...state.filters, ...action.payload }
    },
    
    // UI State
    toggleTaskSelection: (state, action: PayloadAction<string>) => {
      const taskId = action.payload
      const index = state.ui.selectedTasks.indexOf(taskId)
      if (index === -1) {
        state.ui.selectedTasks.push(taskId)
      } else {
        state.ui.selectedTasks.splice(index, 1)
      }
    },
    
    togglePhaseExpansion: (state, action: PayloadAction<ProjectPhase>) => {
      const phase = action.payload
      const index = state.ui.expandedPhases.indexOf(phase)
      if (index === -1) {
        state.ui.expandedPhases.push(phase)
      } else {
        state.ui.expandedPhases.splice(index, 1)
      }
    },
    
    // Loading and Error states
    setLoading: (state, action: PayloadAction<boolean>) => {
      state.isLoading = action.payload
    },
    
    setError: (state, action: PayloadAction<string>) => {
      state.error = action.payload
      state.isLoading = false
    },
  },
})

export const {
  setSchedule,
  setCurrentSchedule,
  updateScheduleSettings,
  addTask,
  updateTask,
  removeTask,
  updateTasksProgress,
  setViewMode,
  setTimeframe,
  setSelectedPhase,
  setFilters,
  toggleTaskSelection,
  togglePhaseExpansion,
  setLoading,
  setError,
} = scheduleSlice.actions

export const scheduleReducer = scheduleSlice.reducer
```

## 2. 일정 관리 Feature Components

### 2.1 Schedule Management Feature

```typescript
// src/features/schedule-management/ui/ScheduleCreator.tsx

import { useState } from 'react'
import { useAppDispatch, useAppSelector } from '@/shared/lib/store'
import { Button, Input } from '@/shared/ui'
import { ProjectSchedule, ScheduleMode } from '@/entities/schedule'

interface ScheduleCreatorProps {
  projectId: number
  onScheduleCreated: (schedule: ProjectSchedule) => void
}

export const ScheduleCreator: React.FC<ScheduleCreatorProps> = ({
  projectId,
  onScheduleCreated
}) => {
  const [mode, setMode] = useState<ScheduleMode>('auto')
  const [settings, setSettings] = useState({
    startDate: '',
    bufferPercentage: 10,
    workingHours: { start: '09:00', end: '18:00' }
  })

  // Auto-generate schedule logic
  const handleAutoGenerate = () => {
    // Implement auto schedule generation based on project type and requirements
  }

  // Manual schedule creation
  const handleManualCreate = () => {
    // Open manual schedule builder
  }

  return (
    <div className="schedule-creator">
      <div className="mode-selector">
        <Button 
          variant={mode === 'auto' ? 'primary' : 'secondary'}
          onClick={() => setMode('auto')}
        >
          자동 생성
        </Button>
        <Button 
          variant={mode === 'manual' ? 'primary' : 'secondary'}
          onClick={() => setMode('manual')}
        >
          수동 설정
        </Button>
      </div>

      {mode === 'auto' ? (
        <AutoScheduleForm 
          settings={settings}
          onGenerate={handleAutoGenerate}
        />
      ) : (
        <ManualScheduleForm 
          onCreateManual={handleManualCreate}
        />
      )}
    </div>
  )
}
```

```typescript
// src/features/schedule-management/ui/TaskManager.tsx

import { useState } from 'react'
import { ScheduleTask, ProjectPhase, TaskStatus } from '@/entities/schedule'
import { Button, Input, Select } from '@/shared/ui'

interface TaskManagerProps {
  tasks: ScheduleTask[]
  phase: ProjectPhase
  onTaskUpdate: (taskId: string, updates: Partial<ScheduleTask>) => void
  onTaskAdd: (task: Omit<ScheduleTask, 'id'>) => void
  onTaskRemove: (taskId: string) => void
}

export const TaskManager: React.FC<TaskManagerProps> = ({
  tasks,
  phase,
  onTaskUpdate,
  onTaskAdd,
  onTaskRemove
}) => {
  const [isAddingTask, setIsAddingTask] = useState(false)
  const [newTask, setNewTask] = useState<Partial<ScheduleTask>>({
    title: '',
    phase,
    status: 'not_started',
    progress: 0
  })

  const handleProgressUpdate = (taskId: string, progress: number) => {
    const status: TaskStatus = progress === 100 ? 'completed' : 
                               progress > 0 ? 'in_progress' : 'not_started'
    onTaskUpdate(taskId, { progress, status })
  }

  return (
    <div className="task-manager">
      <div className="task-list">
        {tasks.map(task => (
          <TaskItem
            key={task.id}
            task={task}
            onProgressUpdate={handleProgressUpdate}
            onUpdate={(updates) => onTaskUpdate(task.id, updates)}
            onRemove={() => onTaskRemove(task.id)}
          />
        ))}
      </div>

      {isAddingTask ? (
        <TaskForm
          task={newTask}
          onChange={setNewTask}
          onSave={() => {
            onTaskAdd(newTask as Omit<ScheduleTask, 'id'>)
            setIsAddingTask(false)
            setNewTask({ title: '', phase, status: 'not_started', progress: 0 })
          }}
          onCancel={() => setIsAddingTask(false)}
        />
      ) : (
        <Button onClick={() => setIsAddingTask(true)}>
          + 작업 추가
        </Button>
      )}
    </div>
  )
}
```

### 2.2 Auto Schedule Generator

```typescript
// src/features/schedule-management/lib/autoScheduleGenerator.ts

import { ProjectSchedule, ScheduleTask, ProjectPhase } from '@/entities/schedule'

interface ProjectTemplate {
  type: 'promotional' | 'documentary' | 'music_video' | 'corporate' | 'custom'
  phases: {
    [K in ProjectPhase]: {
      durationPercentage: number
      defaultTasks: Array<{
        title: string
        durationHours: number
        dependencies?: string[]
        priority: 'low' | 'medium' | 'high' | 'critical'
      }>
    }
  }
}

const VIDEO_TEMPLATES: Record<string, ProjectTemplate> = {
  promotional: {
    type: 'promotional',
    phases: {
      planning: {
        durationPercentage: 30,
        defaultTasks: [
          { title: '컨셉 기획', durationHours: 8, priority: 'critical' },
          { title: '스토리보드 작성', durationHours: 16, dependencies: ['컨셉 기획'], priority: 'high' },
          { title: '촬영 장소 섭외', durationHours: 12, priority: 'high' },
          { title: '출연자 캐스팅', durationHours: 10, priority: 'medium' },
          { title: '촬영 일정 조율', durationHours: 6, dependencies: ['촬영 장소 섭외'], priority: 'high' }
        ]
      },
      shooting: {
        durationPercentage: 40,
        defaultTasks: [
          { title: '촬영 장비 준비', durationHours: 4, priority: 'critical' },
          { title: '메인 씬 촬영', durationHours: 24, dependencies: ['촬영 장비 준비'], priority: 'critical' },
          { title: '보조 씬 촬영', durationHours: 16, dependencies: ['메인 씬 촬영'], priority: 'high' },
          { title: '추가 컷 촬영', durationHours: 8, dependencies: ['보조 씬 촬영'], priority: 'medium' }
        ]
      },
      editing: {
        durationPercentage: 30,
        defaultTasks: [
          { title: '러프 컷 편집', durationHours: 20, priority: 'critical' },
          { title: '파인 컷 편집', durationHours: 16, dependencies: ['러프 컷 편집'], priority: 'high' },
          { title: '컬러 그레이딩', durationHours: 12, dependencies: ['파인 컷 편집'], priority: 'high' },
          { title: '사운드 믹싱', durationHours: 10, dependencies: ['파인 컷 편집'], priority: 'medium' },
          { title: '최종 렌더링', durationHours: 6, dependencies: ['컬러 그레이딩', '사운드 믹싱'], priority: 'high' }
        ]
      }
    }
  },
  // ... 다른 템플릿들
}

export class AutoScheduleGenerator {
  static generateSchedule(
    projectId: number,
    template: string,
    totalDuration: number, // in days
    startDate: Date,
    settings: ProjectSchedule['settings']
  ): ProjectSchedule {
    const templateData = VIDEO_TEMPLATES[template]
    if (!templateData) {
      throw new Error(`Unknown template: ${template}`)
    }

    const schedule: ProjectSchedule = {
      id: crypto.randomUUID(),
      projectId,
      mode: 'auto',
      createdAt: new Date(),
      updatedAt: new Date(),
      settings,
      phases: {} as any,
      milestones: [],
      stats: {
        totalTasks: 0,
        completedTasks: 0,
        overdueTasks: 0,
        totalEstimatedHours: 0,
        totalActualHours: 0,
        averageTaskCompletion: 0,
        phaseCompletionRates: {
          planning: 0,
          shooting: 0,
          editing: 0
        }
      }
    }

    let currentDate = new Date(startDate)
    const workingDaysPerWeek = settings.workingDays.length
    const workingHoursPerDay = this.calculateWorkingHours(settings.workingHours)

    // Generate phases
    for (const [phaseName, phaseData] of Object.entries(templateData.phases)) {
      const phase = phaseName as ProjectPhase
      const phaseDurationDays = Math.ceil((totalDuration * phaseData.durationPercentage) / 100)
      const phaseStartDate = new Date(currentDate)
      const phaseEndDate = this.addWorkingDays(currentDate, phaseDurationDays, settings.workingDays, settings.holidays)

      // Generate tasks for this phase
      const tasks: ScheduleTask[] = phaseData.defaultTasks.map((taskTemplate, index) => ({
        id: crypto.randomUUID(),
        title: taskTemplate.title,
        description: `자동 생성된 ${phase} 단계 작업`,
        phase,
        startDate: new Date(phaseStartDate),
        endDate: new Date(phaseStartDate.getTime() + taskTemplate.durationHours * 60 * 60 * 1000),
        duration: taskTemplate.durationHours,
        progress: 0,
        status: 'not_started' as TaskStatus,
        assignees: [],
        dependencies: taskTemplate.dependencies || [],
        isAutogenerated: true,
        metadata: {
          estimatedHours: taskTemplate.durationHours,
          priority: taskTemplate.priority,
          tags: [phase, 'auto-generated']
        }
      }))

      schedule.phases[phase] = {
        startDate: phaseStartDate,
        endDate: phaseEndDate,
        duration: phaseDurationDays,
        isActive: false,
        progress: 0,
        tasks
      }

      // Add phase milestone
      schedule.milestones.push({
        id: crypto.randomUUID(),
        title: `${this.getPhaseDisplayName(phase)} 완료`,
        date: phaseEndDate,
        phase,
        isCompleted: false,
        description: `${this.getPhaseDisplayName(phase)} 단계의 모든 작업이 완료되는 시점`
      })

      currentDate = phaseEndDate
      schedule.stats.totalTasks += tasks.length
      schedule.stats.totalEstimatedHours += tasks.reduce((sum, task) => sum + task.duration, 0)
    }

    return schedule
  }

  private static calculateWorkingHours(workingHours: { start: string; end: string }): number {
    const start = this.parseTime(workingHours.start)
    const end = this.parseTime(workingHours.end)
    return end - start
  }

  private static parseTime(timeString: string): number {
    const [hours, minutes] = timeString.split(':').map(Number)
    return hours + minutes / 60
  }

  private static addWorkingDays(
    startDate: Date,
    days: number,
    workingDays: number[],
    holidays: Date[]
  ): Date {
    let currentDate = new Date(startDate)
    let addedDays = 0

    while (addedDays < days) {
      currentDate.setDate(currentDate.getDate() + 1)
      
      if (workingDays.includes(currentDate.getDay()) && 
          !holidays.some(holiday => holiday.toDateString() === currentDate.toDateString())) {
        addedDays++
      }
    }

    return currentDate
  }

  private static getPhaseDisplayName(phase: ProjectPhase): string {
    const names = {
      planning: '기획',
      shooting: '촬영',
      editing: '편집'
    }
    return names[phase]
  }
}
```

## 3. Gantt Chart & Calendar Widgets

### 3.1 Gantt Chart Widget

```typescript
// src/widgets/gantt-chart/ui/GanttChart.tsx

import { useCallback, useMemo, useRef, useEffect } from 'react'
import { useAppSelector } from '@/shared/lib/store'
import { ScheduleTask, ProjectPhase } from '@/entities/schedule'

interface GanttChartProps {
  projectId: number
  onTaskUpdate?: (taskId: string, updates: Partial<ScheduleTask>) => void
  onTaskDragEnd?: (taskId: string, newDates: { start: Date; end: Date }) => void
  className?: string
}

export const GanttChart: React.FC<GanttChartProps> = ({
  projectId,
  onTaskUpdate,
  onTaskDragEnd,
  className
}) => {
  const schedule = useAppSelector(state => state.schedule.schedules[projectId])
  const viewMode = useAppSelector(state => state.schedule.viewMode)
  const timeframe = useAppSelector(state => state.schedule.timeframe)
  const filters = useAppSelector(state => state.schedule.filters)

  const svgRef = useRef<SVGSVGElement>(null)

  // Calculate time scale
  const timeScale = useMemo(() => {
    if (!schedule) return null

    const allTasks = Object.values(schedule.phases).flatMap(phase => phase.tasks)
    const startDate = new Date(Math.min(...allTasks.map(task => task.startDate.getTime())))
    const endDate = new Date(Math.max(...allTasks.map(task => task.endDate.getTime())))

    return {
      start: startDate,
      end: endDate,
      duration: endDate.getTime() - startDate.getTime(),
      pixelsPerDay: timeframe === 'day' ? 100 : timeframe === 'week' ? 20 : 5
    }
  }, [schedule, timeframe])

  // Filter tasks
  const filteredTasks = useMemo(() => {
    if (!schedule) return []

    return Object.entries(schedule.phases)
      .filter(([phase]) => filters.phases.length === 0 || filters.phases.includes(phase as ProjectPhase))
      .flatMap(([phase, phaseData]) => 
        phaseData.tasks.filter(task => {
          if (filters.statuses.length > 0 && !filters.statuses.includes(task.status)) return false
          if (filters.assignees.length > 0 && !task.assignees.some(id => filters.assignees.includes(id))) return false
          return true
        })
      )
  }, [schedule, filters])

  // Render timeline
  const renderTimeline = useCallback(() => {
    if (!timeScale) return null

    const days = Math.ceil(timeScale.duration / (24 * 60 * 60 * 1000))
    const timelineItems = []

    for (let i = 0; i <= days; i++) {
      const date = new Date(timeScale.start.getTime() + i * 24 * 60 * 60 * 1000)
      const x = i * timeScale.pixelsPerDay

      timelineItems.push(
        <g key={i}>
          <line 
            x1={x} 
            y1={0} 
            x2={x} 
            y2={filteredTasks.length * 40 + 100} 
            stroke="#e5e7eb" 
            strokeWidth={1}
          />
          <text 
            x={x + 5} 
            y={20} 
            fontSize={12} 
            fill="#6b7280"
          >
            {date.toLocaleDateString('ko-KR', { 
              month: 'short', 
              day: 'numeric' 
            })}
          </text>
        </g>
      )
    }

    return timelineItems
  }, [timeScale, filteredTasks])

  // Render task bars
  const renderTaskBars = useCallback(() => {
    if (!timeScale) return null

    return filteredTasks.map((task, index) => {
      const startX = ((task.startDate.getTime() - timeScale.start.getTime()) / (24 * 60 * 60 * 1000)) * timeScale.pixelsPerDay
      const width = (task.duration / 24) * timeScale.pixelsPerDay
      const y = index * 40 + 40

      const phaseColors = {
        planning: '#3b82f6',
        shooting: '#ef4444', 
        editing: '#10b981'
      }

      return (
        <g key={task.id}>
          {/* Task bar */}
          <rect
            x={startX}
            y={y}
            width={width}
            height={30}
            fill={phaseColors[task.phase]}
            fillOpacity={0.7}
            stroke={phaseColors[task.phase]}
            strokeWidth={1}
            rx={4}
            className="cursor-pointer hover:opacity-90"
            onClick={() => onTaskUpdate?.(task.id, {})}
          />
          
          {/* Progress overlay */}
          <rect
            x={startX}
            y={y}
            width={width * (task.progress / 100)}
            height={30}
            fill={phaseColors[task.phase]}
            fillOpacity={0.9}
            rx={4}
          />
          
          {/* Task label */}
          <text
            x={startX + 8}
            y={y + 20}
            fontSize={12}
            fill="white"
            fontWeight="500"
          >
            {task.title}
          </text>
          
          {/* Progress text */}
          <text
            x={startX + width - 30}
            y={y + 20}
            fontSize={10}
            fill="white"
            fontWeight="600"
          >
            {task.progress}%
          </text>
        </g>
      )
    })
  }, [filteredTasks, timeScale, onTaskUpdate])

  // Render dependencies
  const renderDependencies = useCallback(() => {
    if (!timeScale) return null

    const dependencies = []
    
    filteredTasks.forEach((task, index) => {
      task.dependencies.forEach(depId => {
        const depIndex = filteredTasks.findIndex(t => t.id === depId)
        if (depIndex !== -1) {
          const fromY = depIndex * 40 + 55
          const toY = index * 40 + 55
          const fromX = ((filteredTasks[depIndex].endDate.getTime() - timeScale.start.getTime()) / (24 * 60 * 60 * 1000)) * timeScale.pixelsPerDay
          const toX = ((task.startDate.getTime() - timeScale.start.getTime()) / (24 * 60 * 60 * 1000)) * timeScale.pixelsPerDay

          dependencies.push(
            <g key={`${depId}-${task.id}`}>
              <path
                d={`M ${fromX} ${fromY} L ${toX - 10} ${toY}`}
                stroke="#6b7280"
                strokeWidth={2}
                fill="none"
                markerEnd="url(#arrowhead)"
              />
            </g>
          )
        }
      })
    })

    return dependencies
  }, [filteredTasks, timeScale])

  if (!schedule || !timeScale) {
    return <div className="gantt-chart-loading">간트차트를 로딩 중...</div>
  }

  return (
    <div className={`gantt-chart ${className || ''}`}>
      {/* Header */}
      <div className="gantt-header">
        <h3>프로젝트 일정</h3>
        <div className="gantt-controls">
          {/* View controls will be added here */}
        </div>
      </div>

      {/* Chart */}
      <div className="gantt-container">
        <svg
          ref={svgRef}
          width="100%"
          height={filteredTasks.length * 40 + 100}
          className="gantt-svg"
        >
          <defs>
            <marker
              id="arrowhead"
              markerWidth="10"
              markerHeight="7"
              refX="9"
              refY="3.5"
              orient="auto"
            >
              <polygon
                points="0 0, 10 3.5, 0 7"
                fill="#6b7280"
              />
            </marker>
          </defs>
          
          {renderTimeline()}
          {renderTaskBars()}
          {renderDependencies()}
        </svg>
      </div>

      {/* Legend */}
      <div className="gantt-legend">
        <div className="legend-item">
          <div className="legend-color" style={{ backgroundColor: '#3b82f6' }}></div>
          <span>기획</span>
        </div>
        <div className="legend-item">
          <div className="legend-color" style={{ backgroundColor: '#ef4444' }}></div>
          <span>촬영</span>
        </div>
        <div className="legend-item">
          <div className="legend-color" style={{ backgroundColor: '#10b981' }}></div>
          <span>편집</span>
        </div>
      </div>
    </div>
  )
}
```

### 3.2 Calendar View Widget

```typescript
// src/widgets/calendar-view/ui/CalendarView.tsx

import { useState, useMemo } from 'react'
import { useAppSelector } from '@/shared/lib/store'
import { ScheduleTask, ProjectPhase } from '@/entities/schedule'
import { Button } from '@/shared/ui'

interface CalendarViewProps {
  projectId: number
  onTaskClick?: (task: ScheduleTask) => void
  onDateClick?: (date: Date) => void
  className?: string
}

export const CalendarView: React.FC<CalendarViewProps> = ({
  projectId,
  onTaskClick,
  onDateClick,
  className
}) => {
  const schedule = useAppSelector(state => state.schedule.schedules[projectId])
  const timeframe = useAppSelector(state => state.schedule.timeframe)
  
  const [currentDate, setCurrentDate] = useState(new Date())
  const [viewDate, setViewDate] = useState(new Date())

  // Calculate calendar data
  const calendarData = useMemo(() => {
    if (!schedule) return { days: [], tasks: new Map() }

    const year = viewDate.getFullYear()
    const month = viewDate.getMonth()
    const firstDay = new Date(year, month, 1)
    const lastDay = new Date(year, month + 1, 0)
    const daysInMonth = lastDay.getDate()
    const startDayOfWeek = firstDay.getDay()

    // Generate calendar days
    const days = []
    
    // Previous month days
    const prevMonth = new Date(year, month - 1, 0)
    for (let i = startDayOfWeek - 1; i >= 0; i--) {
      days.push({
        date: new Date(year, month - 1, prevMonth.getDate() - i),
        isCurrentMonth: false,
        isToday: false
      })
    }
    
    // Current month days
    for (let day = 1; day <= daysInMonth; day++) {
      const date = new Date(year, month, day)
      days.push({
        date,
        isCurrentMonth: true,
        isToday: date.toDateString() === currentDate.toDateString()
      })
    }
    
    // Next month days
    const remainingDays = 42 - days.length // 6 weeks * 7 days
    for (let day = 1; day <= remainingDays; day++) {
      days.push({
        date: new Date(year, month + 1, day),
        isCurrentMonth: false,
        isToday: false
      })
    }

    // Group tasks by date
    const tasksByDate = new Map<string, ScheduleTask[]>()
    Object.values(schedule.phases).forEach(phase => {
      phase.tasks.forEach(task => {
        const taskStart = new Date(task.startDate)
        const taskEnd = new Date(task.endDate)
        
        // Add task to each day it spans
        const current = new Date(taskStart)
        while (current <= taskEnd) {
          const dateKey = current.toDateString()
          if (!tasksByDate.has(dateKey)) {
            tasksByDate.set(dateKey, [])
          }
          tasksByDate.get(dateKey)!.push(task)
          current.setDate(current.getDate() + 1)
        }
      })
    })

    return { days, tasks: tasksByDate }
  }, [schedule, viewDate, currentDate])

  const navigateMonth = (direction: 'prev' | 'next') => {
    setViewDate(prev => {
      const newDate = new Date(prev)
      newDate.setMonth(prev.getMonth() + (direction === 'next' ? 1 : -1))
      return newDate
    })
  }

  const renderCalendarDay = (dayData: any) => {
    const { date, isCurrentMonth, isToday } = dayData
    const dateKey = date.toDateString()
    const dayTasks = calendarData.tasks.get(dateKey) || []

    return (
      <div 
        key={dateKey}
        className={`calendar-day ${!isCurrentMonth ? 'other-month' : ''} ${isToday ? 'today' : ''}`}
        onClick={() => onDateClick?.(date)}
      >
        <div className="day-header">
          <span className="day-number">{date.getDate()}</span>
        </div>
        
        <div className="day-tasks">
          {dayTasks.slice(0, 3).map(task => (
            <div
              key={task.id}
              className={`task-item phase-${task.phase}`}
              onClick={(e) => {
                e.stopPropagation()
                onTaskClick?.(task)
              }}
              title={`${task.title} (${task.progress}%)`}
            >
              <span className="task-title">{task.title}</span>
              <span className="task-progress">{task.progress}%</span>
            </div>
          ))}
          
          {dayTasks.length > 3 && (
            <div className="more-tasks">
              +{dayTasks.length - 3} more
            </div>
          )}
        </div>
      </div>
    )
  }

  if (!schedule) {
    return <div className="calendar-loading">캘린더를 로딩 중...</div>
  }

  return (
    <div className={`calendar-view ${className || ''}`}>
      {/* Header */}
      <div className="calendar-header">
        <Button 
          variant="ghost" 
          onClick={() => navigateMonth('prev')}
        >
          ←
        </Button>
        
        <h3>
          {viewDate.toLocaleDateString('ko-KR', { 
            year: 'numeric', 
            month: 'long' 
          })}
        </h3>
        
        <Button 
          variant="ghost" 
          onClick={() => navigateMonth('next')}
        >
          →
        </Button>
      </div>

      {/* Week headers */}
      <div className="calendar-week-headers">
        {['일', '월', '화', '수', '목', '금', '토'].map(day => (
          <div key={day} className="week-header">{day}</div>
        ))}
      </div>

      {/* Calendar grid */}
      <div className="calendar-grid">
        {calendarData.days.map(renderCalendarDay)}
      </div>

      {/* Legend */}
      <div className="calendar-legend">
        <div className="legend-item">
          <div className="legend-color phase-planning"></div>
          <span>기획</span>
        </div>
        <div className="legend-item">
          <div className="legend-color phase-shooting"></div>
          <span>촬영</span>
        </div>
        <div className="legend-item">
          <div className="legend-color phase-editing"></div>
          <span>편집</span>
        </div>
      </div>
    </div>
  )
}
```

## 4. 전체 디렉토리 구조

```
src/
├── entities/
│   ├── schedule/                    # 새로운 Schedule Entity
│   │   ├── index.ts
│   │   ├── model/
│   │   │   ├── types.ts            # Schedule 도메인 타입
│   │   │   ├── schedule.slice.ts   # Redux 상태 관리
│   │   │   └── hooks.ts            # Custom hooks
│   │   ├── api/
│   │   │   └── schedule.api.ts     # API 레이어
│   │   └── lib/
│   │       ├── dateUtils.ts        # 날짜 유틸리티
│   │       └── calculators.ts      # 진행률 계산 등
│   │
│   └── project/                     # 기존 Project Entity 확장
│       ├── model/
│       │   ├── project.slice.ts    # Schedule 참조 추가
│       │   └── types.ts            # ProjectWithSchedule 타입 추가
│
├── features/
│   ├── schedule-management/         # 새로운 일정 관리 Feature
│   │   ├── index.ts
│   │   ├── ui/
│   │   │   ├── ScheduleCreator.tsx         # 일정 생성 폼
│   │   │   ├── AutoScheduleForm.tsx        # 자동 생성 설정
│   │   │   ├── ManualScheduleForm.tsx      # 수동 설정 폼
│   │   │   ├── TaskManager.tsx             # 작업 관리
│   │   │   ├── TaskForm.tsx                # 작업 추가/수정
│   │   │   ├── TaskItem.tsx                # 개별 작업 아이템
│   │   │   ├── PhaseManager.tsx            # 단계별 관리
│   │   │   ├── ProgressTracker.tsx         # 진행률 추적
│   │   │   ├── ScheduleSettings.tsx        # 일정 설정
│   │   │   └── MilestoneManager.tsx        # 마일스톤 관리
│   │   ├── model/
│   │   │   ├── hooks.ts                    # Feature별 hooks
│   │   │   └── utils.ts                    # 유틸리티 함수
│   │   ├── lib/
│   │   │   ├── autoScheduleGenerator.ts    # 자동 일정 생성
│   │   │   ├── templates.ts                # 프로젝트 템플릿
│   │   │   ├── validators.ts               # 일정 유효성 검사
│   │   │   └── progressCalculator.ts       # 진행률 계산
│   │   └── __tests__/
│   │       ├── ScheduleCreator.test.tsx
│   │       └── autoScheduleGenerator.test.ts
│
├── widgets/
│   ├── gantt-chart/                 # 새로운 간트차트 Widget
│   │   ├── index.ts
│   │   ├── ui/
│   │   │   ├── GanttChart.tsx              # 메인 간트차트
│   │   │   ├── GanttTimeline.tsx           # 타임라인 컴포넌트
│   │   │   ├── GanttTaskBar.tsx            # 작업 바
│   │   │   ├── GanttDependency.tsx         # 의존성 표시
│   │   │   ├── GanttControls.tsx           # 차트 컨트롤
│   │   │   ├── GanttTooltip.tsx            # 호버 툴팁
│   │   │   └── GanttLegend.tsx             # 범례
│   │   ├── lib/
│   │   │   ├── calculations.ts             # 좌표 계산
│   │   │   ├── rendering.ts                # 렌더링 로직
│   │   │   └── interactions.ts             # 드래그&드롭 등
│   │   └── __tests__/
│   │       └── GanttChart.test.tsx
│   │
│   ├── calendar-view/               # 새로운 캘린더 Widget
│   │   ├── index.ts
│   │   ├── ui/
│   │   │   ├── CalendarView.tsx            # 메인 캘린더
│   │   │   ├── CalendarDay.tsx             # 개별 날짜 셀
│   │   │   ├── CalendarHeader.tsx          # 헤더 (월/년 네비게이션)
│   │   │   ├── CalendarGrid.tsx            # 캘린더 그리드
│   │   │   ├── TaskPreview.tsx             # 작업 미리보기
│   │   │   └── CalendarControls.tsx        # 뷰 컨트롤
│   │   ├── lib/
│   │   │   ├── dateHelpers.ts              # 날짜 계산
│   │   │   └── taskGrouping.ts             # 작업 그룹핑
│   │   └── __tests__/
│   │       └── CalendarView.test.tsx
│   │
│   └── schedule-dashboard/          # 새로운 일정 대시보드 Widget
│       ├── index.ts
│       ├── ui/
│       │   ├── ScheduleDashboard.tsx       # 메인 대시보드
│       │   ├── ProgressSummary.tsx         # 진행률 요약
│       │   ├── PhaseOverview.tsx           # 단계별 개요
│       │   ├── UpcomingTasks.tsx           # 다가오는 작업
│       │   ├── OverdueTasks.tsx            # 지연된 작업
│       │   ├── MilestoneTimeline.tsx       # 마일스톤 타임라인
│       │   └── ScheduleStats.tsx           # 통계 정보
│       └── __tests__/
│           └── ScheduleDashboard.test.tsx
│
├── app/
│   ├── projects/
│   │   └── [id]/
│   │       ├── schedule/                   # 새로운 일정 페이지
│   │       │   ├── page.tsx               # 일정 메인 페이지
│   │       │   ├── calendar/
│   │       │   │   └── page.tsx           # 캘린더 뷰 페이지
│   │       │   ├── gantt/
│   │       │   │   └── page.tsx           # 간트차트 뷰 페이지
│   │       │   └── settings/
│   │       │       └── page.tsx           # 일정 설정 페이지
│   │       └── page.tsx                   # 기존 프로젝트 상세 (스케줄 탭 추가)
│   │
│   └── dashboard/                          # 기존 대시보드에 일정 정보 추가
│       └── page.tsx                       # 전체 프로젝트 일정 개요
│
└── shared/
    ├── lib/
    │   ├── store/
    │   │   └── index.ts                   # scheduleReducer 추가
    │   └── date/                          # 새로운 날짜 유틸리티
    │       ├── index.ts
    │       ├── formatters.ts
    │       ├── calculations.ts
    │       └── workingDays.ts
    │
    └── ui/
        ├── DatePicker/                    # 새로운 날짜 선택 컴포넌트
        │   ├── DatePicker.tsx
        │   ├── DateRangePicker.tsx
        │   └── DatePicker.module.scss
        ├── ProgressBar/                   # 새로운 진행률 표시 컴포넌트
        │   ├── ProgressBar.tsx
        │   └── ProgressBar.module.scss
        └── StatusBadge/                   # 작업 상태 표시 컴포넌트
            ├── StatusBadge.tsx
            └── StatusBadge.module.scss

## 5. Redux Store 통합 전략

### 5.1 Store 확장

```typescript
// src/shared/lib/store/index.ts (수정사항)

import { scheduleReducer } from '@/entities/schedule'

const rootReducer = combineReducers({
  user: userReducer,
  project: projectReducer,
  feedback: feedbackReducer,
  file: fileReducer,
  planning: planningReducer,
  schedule: scheduleReducer,          // 새로 추가
  auth: authReducer,
  planCreation: planCreationReducer,
})

const persistConfig = {
  key: 'videoplanet',
  storage,
  whitelist: ['user', 'schedule'],    // schedule도 persist 대상에 추가
  blacklist: ['auth'],
}
```

### 5.2 프로젝트 Entity 확장

```typescript
// src/entities/project/model/types.ts (확장)

import { ProjectSchedule } from '@/entities/schedule'

export interface Project {
  id: number
  title: string
  description: string
  color: string
  createdAt: string
  updatedAt: string
  ownerId: number
  status: 'active' | 'completed' | 'archived'
  members: number[]
  
  // 새로 추가되는 일정 관련 필드
  hasSchedule: boolean
  scheduleId?: string
  scheduleLastUpdated?: string
  projectType: 'promotional' | 'documentary' | 'music_video' | 'corporate' | 'custom'
  estimatedDuration?: number // in days
  targetDeadline?: string
}

export interface ProjectWithSchedule extends Project {
  schedule: ProjectSchedule
}
```

```typescript
// src/entities/project/model/project.slice.ts (확장)

const projectSlice = createSlice({
  name: 'project',
  initialState,
  reducers: {
    // 기존 reducers...
    
    // 새로 추가되는 일정 관련 reducers
    attachSchedule: (state, action: PayloadAction<{ projectId: number; scheduleId: string }>) => {
      const { projectId, scheduleId } = action.payload
      const project = state.projects.find(p => p.id === projectId)
      if (project) {
        project.hasSchedule = true
        project.scheduleId = scheduleId
        project.scheduleLastUpdated = new Date().toISOString()
      }
    },
    
    detachSchedule: (state, action: PayloadAction<number>) => {
      const projectId = action.payload
      const project = state.projects.find(p => p.id === projectId)
      if (project) {
        project.hasSchedule = false
        project.scheduleId = undefined
        project.scheduleLastUpdated = undefined
      }
    },
    
    updateProjectType: (state, action: PayloadAction<{ 
      id: number; 
      projectType: Project['projectType'] 
    }>) => {
      const { id, projectType } = action.payload
      const project = state.projects.find(p => p.id === id)
      if (project) {
        project.projectType = projectType
      }
    },
  },
})
```

## 6. 컴포넌트 의존성 다이어그램

```
┌─────────────────────────────────────────────────────────────────┐
│                        APP LAYER                                 │
├─────────────────────────────────────────────────────────────────┤
│  /projects/[id]/schedule/page.tsx                               │
│  /projects/[id]/schedule/gantt/page.tsx                         │
│  /projects/[id]/schedule/calendar/page.tsx                      │
│  /dashboard/page.tsx (일정 개요 추가)                            │
└─────────────────┬───────────────────────────────────────────────┘
                  │
┌─────────────────▼───────────────────────────────────────────────┐
│                      WIDGETS LAYER                              │
├─────────────────────────────────────────────────────────────────┤
│  ScheduleDashboard ◄──► GanttChart ◄──► CalendarView           │
│  │                     │                │                      │
│  ├─ ProgressSummary     ├─ GanttTimeline ├─ CalendarDay         │
│  ├─ PhaseOverview       ├─ GanttTaskBar  ├─ CalendarHeader      │
│  ├─ UpcomingTasks       ├─ GanttControls ├─ TaskPreview         │
│  ├─ OverdueTasks        └─ GanttTooltip  └─ CalendarControls    │
│  └─ MilestoneTimeline                                           │
└─────────────────┬───────────────────────────────────────────────┘
                  │
┌─────────────────▼───────────────────────────────────────────────┐
│                     FEATURES LAYER                              │
├─────────────────────────────────────────────────────────────────┤
│  schedule-management/                                           │
│  │                                                             │
│  ├─ ScheduleCreator ◄──► AutoScheduleForm                      │
│  ├─ TaskManager ◄──────► TaskForm ◄──► TaskItem                │
│  ├─ PhaseManager                                               │
│  ├─ ProgressTracker                                            │
│  ├─ ScheduleSettings                                           │
│  └─ MilestoneManager                                           │
└─────────────────┬───────────────────────────────────────────────┘
                  │
┌─────────────────▼───────────────────────────────────────────────┐
│                    ENTITIES LAYER                               │
├─────────────────────────────────────────────────────────────────┤
│  schedule/                    project/ (확장)                   │
│  │                          │                                  │
│  ├─ schedule.slice.ts ◄─────► project.slice.ts                 │
│  ├─ types.ts                ├─ types.ts (ProjectWithSchedule)   │
│  ├─ hooks.ts                └─ hooks.ts                        │
│  └─ schedule.api.ts                                            │
└─────────────────┬───────────────────────────────────────────────┘
                  │
┌─────────────────▼───────────────────────────────────────────────┐
│                     SHARED LAYER                                │
├─────────────────────────────────────────────────────────────────┤
│  ui/                     lib/                                   │
│  │                      │                                      │
│  ├─ DatePicker           ├─ store/ (Redux)                      │
│  ├─ ProgressBar          ├─ date/ (날짜 유틸리티)                 │
│  ├─ StatusBadge          ├─ utils.ts                           │
│  ├─ Button               └─ validation.ts                       │
│  ├─ Input                                                      │
│  └─ LoadingSpinner                                             │
└─────────────────────────────────────────────────────────────────┘

Dependencies Flow:
- App → Widgets → Features → Entities → Shared
- 상위 레이어는 하위 레이어만 import 가능
- 동일 레이어 내에서는 서로 import 불가 (Features 예외)
- Shared는 모든 레이어에서 사용 가능
```

## 7. 기존 시스템 통합 전략

### 7.1 점진적 마이그레이션 계획

#### Phase 1: 기본 구조 구축 (Week 1-2)
```typescript
// 1. Schedule Entity 생성
- Schedule 타입 정의
- Redux slice 구현
- 기본 API 스텁 생성

// 2. 기존 Project Entity 확장
- Project 타입에 일정 필드 추가
- Project slice에 일정 관련 액션 추가

// 3. 기본 UI 컴포넌트 추가
- DatePicker, ProgressBar, StatusBadge 구현
```

#### Phase 2: Core Features 구현 (Week 3-4)
```typescript
// 1. Schedule Management Feature 구현
- ScheduleCreator 컴포넌트
- 자동 일정 생성 로직
- 기본 작업 관리 기능

// 2. 간단한 일정 보기 구현
- List 형태의 기본 일정 표시
- 진행률 추적 기능
```

#### Phase 3: 고급 시각화 (Week 5-6)
```typescript
// 1. Gantt Chart Widget 구현
- SVG 기반 간트차트
- 드래그 앤 드롭 기능
- 의존성 표시

// 2. Calendar View Widget 구현
- 월간 캘린더 뷰
- 작업 미리보기
- 날짜별 작업 표시
```

#### Phase 4: 고급 기능 및 최적화 (Week 7-8)
```typescript
// 1. 실시간 업데이트 시스템
- WebSocket 연동
- 실시간 진행률 동기화

// 2. 알림 및 자동화 기능
- 데드라인 알림
- 자동 진행률 업데이트

// 3. 성능 최적화
- 메모이제이션 적용
- 가상화 스크롤 구현
```

### 7.2 기존 페이지 통합 방법

#### Dashboard 페이지 확장
```typescript
// src/app/dashboard/page.tsx (수정)

import { ScheduleDashboard } from '@/widgets/schedule-dashboard'
import { useAppSelector } from '@/shared/lib/store'

export default function DashboardPage() {
  const projects = useAppSelector(state => state.project.projects)
  const schedules = useAppSelector(state => state.schedule.schedules)
  
  // 일정이 있는 프로젝트들만 필터링
  const projectsWithSchedules = projects.filter(p => p.hasSchedule)

  return (
    <div className="dashboard">
      {/* 기존 대시보드 컨텐츠 */}
      
      {/* 새로 추가되는 일정 개요 섹션 */}
      <section className="schedule-overview">
        <h2>프로젝트 일정 개요</h2>
        <ScheduleDashboard 
          projects={projectsWithSchedules}
          schedules={schedules}
          showSummaryOnly={true}
        />
      </section>
    </div>
  )
}
```

#### 프로젝트 상세 페이지 확장
```typescript
// src/app/projects/[id]/page.tsx (수정)

import { TabView } from '@/shared/ui'
import { ScheduleDashboard } from '@/widgets/schedule-dashboard'

export default function ProjectDetailPage({ params }: { params: { id: string } }) {
  const projectId = parseInt(params.id)
  const project = useAppSelector(state => 
    state.project.projects.find(p => p.id === projectId)
  )

  const tabs = [
    { id: 'overview', label: '개요', content: <ProjectOverview project={project} /> },
    { id: 'feedback', label: '피드백', content: <FeedbackSection projectId={projectId} /> },
    { id: 'files', label: '파일', content: <FilesSection projectId={projectId} /> },
    // 새로 추가되는 일정 탭
    { 
      id: 'schedule', 
      label: '일정', 
      content: project?.hasSchedule ? 
        <ScheduleDashboard projectId={projectId} /> :
        <ScheduleCreator projectId={projectId} />
    },
  ]

  return (
    <div className="project-detail">
      <TabView tabs={tabs} />
    </div>
  )
}
```

## 8. 실시간 업데이트 아키텍처

### 8.1 WebSocket 통합

```typescript
// src/shared/lib/websocket/scheduleSocket.ts

export class ScheduleWebSocket {
  private ws: WebSocket | null = null
  private reconnectAttempts = 0
  private maxReconnectAttempts = 5
  private reconnectDelay = 1000

  constructor(
    private dispatch: AppDispatch,
    private projectId: number
  ) {}

  connect() {
    const wsUrl = `${process.env.NEXT_PUBLIC_WS_URL}/schedule/${this.projectId}`
    this.ws = new WebSocket(wsUrl)

    this.ws.onopen = () => {
      console.log('Schedule WebSocket connected')
      this.reconnectAttempts = 0
    }

    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data)
      this.handleMessage(data)
    }

    this.ws.onclose = () => {
      console.log('Schedule WebSocket disconnected')
      this.handleReconnect()
    }

    this.ws.onerror = (error) => {
      console.error('Schedule WebSocket error:', error)
    }
  }

  private handleMessage(data: any) {
    switch (data.type) {
      case 'TASK_PROGRESS_UPDATE':
        this.dispatch(updateTask({
          projectId: this.projectId,
          taskId: data.taskId,
          updates: { progress: data.progress, status: data.status }
        }))
        break

      case 'TASK_CREATED':
        this.dispatch(addTask({
          projectId: this.projectId,
          phase: data.task.phase,
          task: data.task
        }))
        break

      case 'SCHEDULE_UPDATED':
        this.dispatch(setSchedule(data.schedule))
        break
    }
  }

  sendProgressUpdate(taskId: string, progress: number) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({
        type: 'UPDATE_TASK_PROGRESS',
        taskId,
        progress,
        timestamp: new Date().toISOString()
      }))
    }
  }

  private handleReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      setTimeout(() => {
        this.reconnectAttempts++
        this.connect()
      }, this.reconnectDelay * Math.pow(2, this.reconnectAttempts))
    }
  }

  disconnect() {
    this.ws?.close()
  }
}
```

### 8.2 실시간 훅

```typescript
// src/entities/schedule/model/hooks.ts

import { useEffect, useMemo } from 'react'
import { useAppDispatch, useAppSelector } from '@/shared/lib/store'
import { ScheduleWebSocket } from '@/shared/lib/websocket/scheduleSocket'

export const useScheduleRealtime = (projectId: number) => {
  const dispatch = useAppDispatch()
  const schedule = useAppSelector(state => state.schedule.schedules[projectId])

  const websocket = useMemo(() => {
    return new ScheduleWebSocket(dispatch, projectId)
  }, [dispatch, projectId])

  useEffect(() => {
    if (schedule) {
      websocket.connect()
      return () => websocket.disconnect()
    }
  }, [websocket, schedule])

  return {
    sendProgressUpdate: websocket.sendProgressUpdate.bind(websocket),
    isConnected: websocket.isConnected
  }
}

export const useScheduleStats = (projectId: number) => {
  const schedule = useAppSelector(state => state.schedule.schedules[projectId])

  return useMemo(() => {
    if (!schedule) return null

    const allTasks = Object.values(schedule.phases).flatMap(phase => phase.tasks)
    const completedTasks = allTasks.filter(task => task.status === 'completed')
    const overdueTasks = allTasks.filter(task => 
      task.status !== 'completed' && new Date(task.endDate) < new Date()
    )

    const totalProgress = allTasks.length > 0 
      ? allTasks.reduce((sum, task) => sum + task.progress, 0) / allTasks.length
      : 0

    const phaseProgress = Object.entries(schedule.phases).reduce((acc, [phase, data]) => {
      const phaseTasks = data.tasks
      const phaseAvg = phaseTasks.length > 0
        ? phaseTasks.reduce((sum, task) => sum + task.progress, 0) / phaseTasks.length
        : 0
      acc[phase as keyof typeof acc] = phaseAvg
      return acc
    }, { planning: 0, shooting: 0, editing: 0 })

    return {
      totalTasks: allTasks.length,
      completedTasks: completedTasks.length,
      overdueTasks: overdueTasks.length,
      totalProgress,
      phaseProgress,
      estimatedCompletion: calculateEstimatedCompletion(allTasks),
      isOnTrack: overdueTasks.length === 0 && totalProgress >= getExpectedProgress(schedule)
    }
  }, [schedule, projectId])
}

// 예상 완료일 계산
function calculateEstimatedCompletion(tasks: ScheduleTask[]): Date | null {
  const remainingTasks = tasks.filter(task => task.status !== 'completed')
  if (remainingTasks.length === 0) return new Date()

  const totalRemainingHours = remainingTasks.reduce((sum, task) => {
    const remainingProgress = 100 - task.progress
    const remainingHours = (task.metadata.estimatedHours * remainingProgress) / 100
    return sum + remainingHours
  }, 0)

  const workingHoursPerDay = 8 // 설정에서 가져와야 함
  const remainingDays = Math.ceil(totalRemainingHours / workingHoursPerDay)
  
  const completion = new Date()
  completion.setDate(completion.getDate() + remainingDays)
  return completion
}

// 현재 시점에서 기대되는 진행률 계산
function getExpectedProgress(schedule: ProjectSchedule): number {
  const now = new Date()
  const start = new Date(Object.values(schedule.phases)[0].startDate)
  const end = new Date(Object.values(schedule.phases)[2].endDate)
  
  const totalDuration = end.getTime() - start.getTime()
  const elapsed = now.getTime() - start.getTime()
  
  return Math.max(0, Math.min(100, (elapsed / totalDuration) * 100))
}
```

## 9. 성능 최적화 전략

### 9.1 메모이제이션 및 가상화

```typescript
// src/widgets/gantt-chart/ui/VirtualizedGanttChart.tsx

import { FixedSizeList as List } from 'react-window'
import { memo, useMemo } from 'react'

interface VirtualizedGanttChartProps {
  projectId: number
  height: number
  itemHeight: number
}

export const VirtualizedGanttChart = memo<VirtualizedGanttChartProps>(({
  projectId,
  height,
  itemHeight
}) => {
  const schedule = useAppSelector(state => state.schedule.schedules[projectId])
  const filteredTasks = useAppSelector(state => {
    // 복잡한 필터링 로직
    return selectFilteredTasks(state, projectId)
  }, shallowEqual)

  const memoizedTaskItems = useMemo(() => 
    filteredTasks.map(task => ({
      ...task,
      renderData: calculateTaskRenderData(task)
    })), 
    [filteredTasks]
  )

  const renderTaskRow = useCallback(({ index, style }: any) => {
    const task = memoizedTaskItems[index]
    return (
      <div style={style}>
        <GanttTaskBar task={task} />
      </div>
    )
  }, [memoizedTaskItems])

  return (
    <List
      height={height}
      itemCount={memoizedTaskItems.length}
      itemSize={itemHeight}
      width="100%"
    >
      {renderTaskRow}
    </List>
  )
})
```

### 9.2 선택적 리렌더링

```typescript
// src/entities/schedule/model/selectors.ts

export const selectFilteredTasks = createSelector(
  [
    (state: RootState) => state.schedule.schedules,
    (state: RootState, projectId: number) => projectId,
    (state: RootState) => state.schedule.filters,
  ],
  (schedules, projectId, filters) => {
    const schedule = schedules[projectId]
    if (!schedule) return []

    return Object.values(schedule.phases)
      .flatMap(phase => phase.tasks)
      .filter(task => {
        if (filters.phases.length > 0 && !filters.phases.includes(task.phase)) return false
        if (filters.statuses.length > 0 && !filters.statuses.includes(task.status)) return false
        if (filters.assignees.length > 0 && !task.assignees.some(id => filters.assignees.includes(id))) return false
        return true
      })
  }
)

export const selectScheduleStats = createSelector(
  [(state: RootState, projectId: number) => state.schedule.schedules[projectId]],
  (schedule) => {
    if (!schedule) return null
    
    // 통계 계산 로직
    return calculateScheduleStatistics(schedule)
  }
)
```

## 10. 테스트 전략

### 10.1 Unit Tests

```typescript
// src/entities/schedule/__tests__/schedule.slice.test.ts

import { scheduleReducer, addTask, updateTask } from '../model/schedule.slice'
import { ScheduleTask, ProjectSchedule } from '../model/types'

describe('Schedule Slice', () => {
  const initialState = {
    schedules: {},
    currentSchedule: null,
    // ... other initial state
  }

  const mockTask: ScheduleTask = {
    id: 'task-1',
    title: 'Test Task',
    phase: 'planning',
    startDate: new Date('2025-01-01'),
    endDate: new Date('2025-01-02'),
    duration: 8,
    progress: 0,
    status: 'not_started',
    assignees: [],
    dependencies: [],
    isAutogenerated: false,
    metadata: {
      estimatedHours: 8,
      priority: 'medium',
      tags: ['test']
    }
  }

  it('should add task to correct phase', () => {
    const action = addTask({
      projectId: 1,
      phase: 'planning',
      task: mockTask
    })

    const newState = scheduleReducer(initialState, action)
    
    expect(newState.schedules[1].phases.planning.tasks).toContain(mockTask)
  })

  it('should update task progress', () => {
    const stateWithTask = {
      ...initialState,
      schedules: {
        1: {
          phases: {
            planning: { tasks: [mockTask] }
          }
        }
      }
    }

    const action = updateTask({
      projectId: 1,
      taskId: 'task-1',
      updates: { progress: 50, status: 'in_progress' }
    })

    const newState = scheduleReducer(stateWithTask, action)
    const updatedTask = newState.schedules[1].phases.planning.tasks[0]
    
    expect(updatedTask.progress).toBe(50)
    expect(updatedTask.status).toBe('in_progress')
  })
})
```

### 10.2 Component Tests

```typescript
// src/widgets/gantt-chart/__tests__/GanttChart.test.tsx

import { render, screen, fireEvent } from '@testing-library/react'
import { Provider } from 'react-redux'
import { GanttChart } from '../ui/GanttChart'
import { createMockStore } from '@/test/utils'

describe('GanttChart', () => {
  const mockStore = createMockStore({
    schedule: {
      schedules: {
        1: {
          phases: {
            planning: {
              tasks: [
                {
                  id: 'task-1',
                  title: 'Planning Task',
                  phase: 'planning',
                  startDate: new Date('2025-01-01'),
                  endDate: new Date('2025-01-02'),
                  progress: 25
                }
              ]
            }
          }
        }
      }
    }
  })

  it('renders task bars correctly', () => {
    render(
      <Provider store={mockStore}>
        <GanttChart projectId={1} />
      </Provider>
    )

    expect(screen.getByText('Planning Task')).toBeInTheDocument()
    expect(screen.getByText('25%')).toBeInTheDocument()
  })

  it('calls onTaskUpdate when task is clicked', () => {
    const mockOnTaskUpdate = vi.fn()
    
    render(
      <Provider store={mockStore}>
        <GanttChart projectId={1} onTaskUpdate={mockOnTaskUpdate} />
      </Provider>
    )

    fireEvent.click(screen.getByText('Planning Task'))
    expect(mockOnTaskUpdate).toHaveBeenCalledWith('task-1', {})
  })
})
```

### 10.3 Integration Tests

```typescript
// src/features/schedule-management/__tests__/integration.test.tsx

import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { Provider } from 'react-redux'
import { ScheduleCreator } from '../ui/ScheduleCreator'
import { createMockStore } from '@/test/utils'

describe('Schedule Management Integration', () => {
  it('creates schedule and adds tasks', async () => {
    const user = userEvent.setup()
    const mockStore = createMockStore()

    render(
      <Provider store={mockStore}>
        <ScheduleCreator projectId={1} onScheduleCreated={vi.fn()} />
      </Provider>
    )

    // 자동 생성 모드 선택
    await user.click(screen.getByText('자동 생성'))
    
    // 프로젝트 타입 선택
    await user.selectOptions(screen.getByLabelText('프로젝트 유형'), 'promotional')
    
    // 기간 설정
    await user.type(screen.getByLabelText('전체 기간'), '30')
    
    // 일정 생성
    await user.click(screen.getByText('일정 생성'))

    await waitFor(() => {
      const state = mockStore.getState()
      expect(state.schedule.schedules[1]).toBeDefined()
      expect(state.schedule.schedules[1].phases.planning.tasks.length).toBeGreaterThan(0)
    })
  })
})
```

## 11. 마이그레이션 체크리스트

### Phase 1 체크리스트
- [ ] Schedule Entity 구조 생성
- [ ] Redux store에 scheduleReducer 추가
- [ ] 기본 타입 정의 완료
- [ ] Project Entity 확장 완료
- [ ] 기본 UI 컴포넌트 (DatePicker, ProgressBar, StatusBadge) 구현

### Phase 2 체크리스트
- [ ] ScheduleCreator 컴포넌트 구현
- [ ] AutoScheduleGenerator 로직 구현
- [ ] TaskManager 기본 기능 구현
- [ ] 프로젝트 상세 페이지에 일정 탭 추가
- [ ] 기본 테스트 커버리지 70% 달성

### Phase 3 체크리스트
- [ ] GanttChart Widget 구현
- [ ] CalendarView Widget 구현
- [ ] 드래그 앤 드롭 기능 구현
- [ ] 일정 전용 페이지 생성
- [ ] 모바일 반응형 최적화

### Phase 4 체크리스트
- [ ] WebSocket 실시간 업데이트 구현
- [ ] 성능 최적화 (가상화, 메모이제이션) 적용
- [ ] 알림 시스템 구현
- [ ] E2E 테스트 구현
- [ ] 프로덕션 배포 및 모니터링 설정

## 12. ADR (Architecture Decision Records)

### ADR-001: FSD 아키텍처 채택
**상황**: 복잡한 일정 관리 시스템을 확장 가능하고 유지보수하기 쉽게 구조화해야 함  
**결정**: Feature-Sliced Design 아키텍처 패턴 채택  
**근거**: 레이어 간 명확한 의존성, 기존 시스템과의 일관성, 팀의 기존 숙련도  
**결과**: 예측 가능한 구조와 테스트 가능한 코드베이스

### ADR-002: Redux Toolkit을 통한 상태 관리
**상황**: 복잡한 일정 데이터와 실시간 업데이트를 효율적으로 관리해야 함  
**결정**: Redux Toolkit 확장 사용  
**근거**: 기존 시스템과의 일관성, 타임 트래블 디버깅, 예측 가능한 상태 업데이트  
**결과**: 중앙화된 상태 관리와 개발자 도구 지원

### ADR-003: SVG 기반 간트차트 구현
**상황**: 간트차트 시각화를 위한 라이브러리 선택  
**결정**: 서드파티 라이브러리 대신 SVG 직접 구현  
**근거**: 커스터마이징 유연성, 번들 크기 최적화, 성능 제어  
**결과**: 높은 커스터마이징 가능성, 학습 곡선 증가

### ADR-004: WebSocket을 통한 실시간 업데이트
**상황**: 다중 사용자 환경에서 실시간 일정 동기화 필요  
**결정**: WebSocket 기반 실시간 통신 구현  
**근거**: 낮은 지연시간, 양방향 통신, 서버 부하 최적화  
**결과**: 실시간 협업 가능, 인프라 복잡성 증가
```